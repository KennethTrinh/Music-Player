'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _PriorityQueue = require('../core/PriorityQueue');

var _PriorityQueue2 = _interopRequireDefault(_PriorityQueue);

var _SchedulingQueue2 = require('../core/SchedulingQueue');

var _SchedulingQueue3 = _interopRequireDefault(_SchedulingQueue2);

var _TimeEngine4 = require('../core/TimeEngine');

var _TimeEngine5 = _interopRequireDefault(_TimeEngine4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) {
        this.stop(time, position - this.__offsetPosition);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'audioTime',
    get: function get() {
      return this.master.audioTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_TimeEngine5.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position
// @note - does not handle properly __startPosition and __endPosition


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  // @todo - handle this.__running to start and stop properly the scheduled engines


  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var nextPosition = null; // Infinity * speed; // default return

      if (speed > 0) {

        if (position < this.__startPosition) {
          // sync engine at `_startPosition`
          nextPosition = this.__offsetPosition + this.__engine.syncPosition(time, this.__startPosition - this.__offsetPosition, speed);
          this.__isRunning = true;
        } else if (position < this.__endPosition) {
          // sync engine at `position`
          nextPosition = this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
          this.__isRunning = true;
        } else {
          this.__engine.syncPosition(time, position - this.__offsetPosition, 0);

          this.__isRunning = false;
          nextPosition = Infinity * speed;
        }

        // if somehow the engine asked to be called after `endPosition`, clamp value
        if (this.__isRunning && nextPosition > this.__endPosition) {
          nextPosition = this.__endPosition;
        }
      } else if (speed < 0) {

        if (position > this.__endPosition) {
          nextPosition = this.__offsetPosition + this.__engine.syncPosition(time, this.__endPosition - this.__offsetPosition, speed);
          this.__isRunning = true;
        } else if (position > this.__startPosition) {
          nextPosition = this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
          this.__isRunning = true;
        } else {
          this.__engine.syncPosition(time, position - this.__offsetPosition, 0);

          this.__isRunning = false;
          nextPosition = Infinity * speed;
        }

        // if somehow the engine asked to be called before `startPosition`, clamp value
        if (this.__isRunning && nextPosition < this.__startPosition) {
          nextPosition = this.__startPosition;
        }
      } else {
        this.__engine.syncPosition(time, position - this.__offsetPosition, 0);

        this.__isRunning = false;
        nextPosition = Infinity;
      }

      return nextPosition;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      // ceil or floor `position` at 10^-9 to prevent float arithmetics errors
      // that make the transported go to infinite loops
      if (speed > 0) {
        position = Math.ceil(position * 1e9) * 1e-9;
      } else if (speed < 0) {
        position = Math.floor(position * 1e9) * 1e-9;
      }

      // stop engine if outside boundaries
      if (speed > 0 && position >= this.__endPosition && this.__isRunning) {
        // stop engine at __endPosition
        this.__engine.syncPosition(time, this.__endPosition - this.__offsetPosition, 0);
        this.__isRunning = false;

        return Infinity * speed; //
      } else if (speed < 0 && position < this.__startPosition && this.__isRunning) {
        this.__engine.syncPosition(time, this.__startPosition - this.__offsetPosition, 0);
        this.__isRunning = false;

        return Infinity * speed; //
      }

      // define next position and clamp to boundaries
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      // stop engine if outside boundaries - will call advancePosition once more
      // and thus `syncPosition` (cf. line 218 - 228)
      if (speed > 0 && position > this.__endPosition) {
        position = this.__endPosition;
      } else if (speed < 0 && position < this.__startPosition) {
        position = this.__startPosition;
      }

      return position;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) {
        this.__engine.syncSpeed(time, position, speed);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) {
        position += this.__offsetPosition;
      }

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncPosition(this.master.currentTime, this.master.currentPosition, 0);
      (0, _get3.default)(TransportedTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_TimeEngine5.default);

// internal scheduling queue that returns the current position (and time) of the transport


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'audioTime',
    get: function get() {
      return this.__transport.audioTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_SchedulingQueue3.default);

/**
 * Provides position-based scheduling of TimeEngine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-masters/master/examples/transport/index.html}
 *
 *
 * @param {Object} scheduler - instance of Scheduler
 *
 * @example
 * import * as masters from 'waves-masters';
 *
 * const getTimeFunction = () => {
 *   const now = process.hrtime();
 *   return now[0] + now[1] * 1e-9;
 * }
 * const scheduler = new masters.Scheduler(getTimeFunction);
 * const transport = new masters.Transport(scheduler);
 * const playControl = new masters.PlayControl(scheduler, transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport(scheduler) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    if (!scheduler) throw new Error('Invalid argument `scheduler`, should be an instance of `Scheduler`');

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = scheduler;
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _PriorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      if (this.__speed === 0) return +Infinity;else return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time.
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedPosition(time, position, speed);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_TimeEngine5.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_TimeEngine5.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_TimeEngine5.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = null;

        // the priority queue does not keep track of the elements that are
        // inserted at Infinity, so we need to reinsert transported engine in
        // this case.
        // @note - this could probably be more clean
        //       - probably the priority queue should keep these references
        if (!this.__transportedQueue.has(transported)) {
          nextPosition = this.__transportedQueue.insert(transported, position);
        } else {
          nextPosition = this.__transportedQueue.move(transported, position);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get master audio time.
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'audioTime',
    get: function get() {
      return this.__scheduler.audioTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_TimeEngine5.default);

exports.default = Transport;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlRyYW5zcG9ydC5qcyJdLCJuYW1lcyI6WyJhZGREdXBsZXQiLCJmaXJzdEFycmF5Iiwic2Vjb25kQXJyYXkiLCJmaXJzdEVsZW1lbnQiLCJzZWNvbmRFbGVtZW50IiwicHVzaCIsInJlbW92ZUR1cGxldCIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIlRyYW5zcG9ydGVkIiwidHJhbnNwb3J0IiwiZW5naW5lIiwic3RhcnQiLCJkdXJhdGlvbiIsIm9mZnNldCIsInN0cmV0Y2giLCJtYXN0ZXIiLCJfX2VuZ2luZSIsIl9fc3RhcnRQb3NpdGlvbiIsIl9fZW5kUG9zaXRpb24iLCJpc0Zpbml0ZSIsIkluZmluaXR5IiwiX19vZmZzZXRQb3NpdGlvbiIsIl9fc3RyZXRjaFBvc2l0aW9uIiwiX19pc1J1bm5pbmciLCJyZXNldFBvc2l0aW9uIiwidGltZSIsInBvc2l0aW9uIiwic3BlZWQiLCJ1bmRlZmluZWQiLCJyZXNldEVuZ2luZVBvc2l0aW9uIiwic3RvcCIsImN1cnJlbnRUaW1lIiwiYXVkaW9UaW1lIiwiY3VycmVudFBvc2l0aW9uIiwiVGltZUVuZ2luZSIsIlRyYW5zcG9ydGVkVHJhbnNwb3J0ZWQiLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJvZmZzZXRQb3NpdGlvbiIsIm5leHRQb3NpdGlvbiIsInN5bmNQb3NpdGlvbiIsIk1hdGgiLCJjZWlsIiwiZmxvb3IiLCJhZHZhbmNlUG9zaXRpb24iLCJzeW5jU3BlZWQiLCJUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZCIsIlRyYW5zcG9ydGVkU2NoZWR1bGVkIiwiX19zY2hlZHVsaW5nUXVldWUiLCJhZGQiLCJyZXNldEVuZ2luZVRpbWUiLCJyZW1vdmUiLCJUcmFuc3BvcnRTY2hlZHVsZXJIb29rIiwiX190cmFuc3BvcnQiLCJfX25leHRQb3NpdGlvbiIsIl9fbmV4dFRpbWUiLCJfX3NjaGVkdWxlciIsIl9fc3BlZWQiLCJuZXh0VGltZSIsIl9fZ2V0VGltZUF0UG9zaXRpb24iLCJyZXNldFRpbWUiLCJUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUiLCJTY2hlZHVsaW5nUXVldWUiLCJUcmFuc3BvcnQiLCJzY2hlZHVsZXIiLCJvcHRpb25zIiwiRXJyb3IiLCJfX2VuZ2luZXMiLCJfX3RyYW5zcG9ydGVkIiwiX19zY2hlZHVsZXJIb29rIiwiX190cmFuc3BvcnRlZFF1ZXVlIiwiUHJpb3JpdHlRdWV1ZSIsIl9fdGltZSIsIl9fcG9zaXRpb24iLCJudW1UcmFuc3BvcnRlZEVuZ2luZXMiLCJsZW5ndGgiLCJjbGVhciIsInJldmVyc2UiLCJpIiwibmV4dEVuZ2luZVBvc2l0aW9uIiwiaW5zZXJ0IiwidHJhbnNwb3J0ZWQiLCJfX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uIiwiaGVhZCIsIm1vdmUiLCJzZWVrIiwibGFzdFNwZWVkIiwiX19zeW5jVHJhbnNwb3J0ZWRTcGVlZCIsImltcGxlbWVudHNUcmFuc3BvcnRlZCIsImltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQiLCJpbXBsZW1lbnRzU2NoZWR1bGVkIiwiZW5naW5lT3JUcmFuc3BvcnRlZCIsImRlc3Ryb3kiLCJoYXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBLFNBQVNBLFNBQVQsQ0FBbUJDLFVBQW5CLEVBQStCQyxXQUEvQixFQUE0Q0MsWUFBNUMsRUFBMERDLGFBQTFELEVBQXlFO0FBQ3ZFSCxhQUFXSSxJQUFYLENBQWdCRixZQUFoQjtBQUNBRCxjQUFZRyxJQUFaLENBQWlCRCxhQUFqQjtBQUNEOztBQUVELFNBQVNFLFlBQVQsQ0FBc0JMLFVBQXRCLEVBQWtDQyxXQUFsQyxFQUErQ0MsWUFBL0MsRUFBNkQ7QUFDM0QsTUFBTUksUUFBUU4sV0FBV08sT0FBWCxDQUFtQkwsWUFBbkIsQ0FBZDs7QUFFQSxNQUFJSSxTQUFTLENBQWIsRUFBZ0I7QUFDZCxRQUFNSCxnQkFBZ0JGLFlBQVlLLEtBQVosQ0FBdEI7O0FBRUFOLGVBQVdRLE1BQVgs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QUFwQixFQUFpQyxLQUFLRSxlQUF0QyxFQUF1RCxDQUF2RDs7QUFETTtBQUFBO0FBQUE7O0FBQUE7QUFHTix5REFBd0IsS0FBS21DLGFBQTdCO0FBQUEsY0FBU2EsV0FBVDs7QUFDRUEsc0JBQVlXLE9BQVo7QUFERjtBQUhNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLUDs7O3dCQTdOaUI7QUFDaEIsYUFBTyxLQUFLcEMsV0FBTCxDQUFpQnpCLFdBQXhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozt3QkFTZ0I7QUFDZCxhQUFPLEtBQUt5QixXQUFMLENBQWlCeEIsU0FBeEI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozt3QkFVc0I7QUFDcEIsVUFBTWpCLFNBQVMsS0FBS0EsTUFBcEI7O0FBRUEsVUFBSUEsVUFBVUEsT0FBT2tCLGVBQVAsS0FBMkJMLFNBQXpDLEVBQ0UsT0FBT2IsT0FBT2tCLGVBQWQ7O0FBRUYsYUFBTyxLQUFLd0MsVUFBTCxHQUFrQixDQUFDLEtBQUtqQixXQUFMLENBQWlCekIsV0FBakIsR0FBK0IsS0FBS3lDLE1BQXJDLElBQStDLEtBQUtmLE9BQTdFO0FBQ0Q7OztFQXBHcUJ2QixvQjs7a0JBa1NUNkIsUyIsImZpbGUiOiJUcmFuc3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuLi9jb3JlL1ByaW9yaXR5UXVldWUnO1xuaW1wb3J0IFNjaGVkdWxpbmdRdWV1ZSBmcm9tICcuLi9jb3JlL1NjaGVkdWxpbmdRdWV1ZSc7XG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL1RpbWVFbmdpbmUnO1xuXG5cbmZ1bmN0aW9uIGFkZER1cGxldChmaXJzdEFycmF5LCBzZWNvbmRBcnJheSwgZmlyc3RFbGVtZW50LCBzZWNvbmRFbGVtZW50KSB7XG4gIGZpcnN0QXJyYXkucHVzaChmaXJzdEVsZW1lbnQpO1xuICBzZWNvbmRBcnJheS5wdXNoKHNlY29uZEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsZXQoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGZpcnN0RWxlbWVudCkge1xuICBjb25zdCBpbmRleCA9IGZpcnN0QXJyYXkuaW5kZXhPZihmaXJzdEVsZW1lbnQpO1xuXG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgY29uc3Qgc2Vjb25kRWxlbWVudCA9IHNlY29uZEFycmF5W2luZGV4XTtcblxuICAgIGZpcnN0QXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBzZWNvbmRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgcmV0dXJuIHNlY29uZEVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhlIFRyYW5zcG9ydGVkIGNhbGwgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgdGhlIGFkYXB0ZXJzIGJldHdlZW5cbi8vIGRpZmZlcmVudCB0eXBlcyBvZiBlbmdpbmVzIChpLmUuIHRyYW5zcG9ydGVkLCBzY2hlZHVsZWQsIHBsYXktY29udHJvbGxlZClcbi8vIFRoZSBhZGFwdGVycyBhcmUgYXQgdGhlIHNhbWUgdGltZSBtYXN0ZXJzIGZvciB0aGUgZW5naW5lcyBhZGRlZCB0byB0aGUgdHJhbnNwb3J0XG4vLyBhbmQgdHJhbnNwb3J0ZWQgVGltZUVuZ2luZXMgaW5zZXJ0ZWQgaW50byB0aGUgdHJhbnNwb3J0J3MgcG9zaXRpb24tYmFzZWQgcHJpdG9yaXR5IHF1ZXVlLlxuY2xhc3MgVHJhbnNwb3J0ZWQgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0LCBzdHJldGNoID0gMSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYXN0ZXIgPSB0cmFuc3BvcnQ7XG5cbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xuXG4gICAgdGhpcy5fX3N0YXJ0UG9zaXRpb24gPSBzdGFydDtcbiAgICB0aGlzLl9fZW5kUG9zaXRpb24gPSAhaXNGaW5pdGUoZHVyYXRpb24pID8gSW5maW5pdHkgOiBzdGFydCArIGR1cmF0aW9uO1xuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgIHRoaXMuX19zdHJldGNoUG9zaXRpb24gPSBzdHJldGNoO1xuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHNldEJvdW5kYXJpZXMoc3RhcnQsIGR1cmF0aW9uLCBvZmZzZXQgPSAwLCBzdHJldGNoID0gMSkge1xuICAgIHRoaXMuX19zdGFydFBvc2l0aW9uID0gc3RhcnQ7XG4gICAgdGhpcy5fX2VuZFBvc2l0aW9uID0gc3RhcnQgKyBkdXJhdGlvbjtcbiAgICB0aGlzLl9fb2Zmc2V0UG9zaXRpb24gPSBzdGFydCArIG9mZnNldDtcbiAgICB0aGlzLl9fc3RyZXRjaFBvc2l0aW9uID0gc3RyZXRjaDtcbiAgICB0aGlzLnJlc2V0UG9zaXRpb24oKTtcbiAgfVxuXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge31cbiAgc3RvcCh0aW1lLCBwb3NpdGlvbikge31cblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZ2V0IGF1ZGlvVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuYXVkaW9UaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xuICB9XG5cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgcG9zaXRpb24gKz0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xuXG4gICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG4gIH1cblxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKHNwZWVkID4gMCkge1xuICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcblxuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZylcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5kUG9zaXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiB0aGlzLl9fc3RhcnRQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcbiAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbik7XG5cbiAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIEluZmluaXR5ICogc3BlZWQ7XG4gIH1cblxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgaWYgKCF0aGlzLl9faXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHNwZWVkID4gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIHN0b3AgZW5naW5lXG4gICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcblxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1hc3RlciA9IG51bGw7XG5cbiAgICB0aGlzLl9fZW5naW5lLm1hc3RlciA9IG51bGw7XG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XG4gIH1cbn1cblxuLy8gVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZFxuLy8gaGFzIHRvIHN3aXRjaCBvbiBhbmQgb2ZmIHRoZSBzY2hlZHVsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxuLy8gQG5vdGUgLSBkb2VzIG5vdCBoYW5kbGUgcHJvcGVybHkgX19zdGFydFBvc2l0aW9uIGFuZCBfX2VuZFBvc2l0aW9uXG5jbGFzcyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkIGV4dGVuZHMgVHJhbnNwb3J0ZWQge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG4gIH1cblxuICAvLyBAdG9kbyAtIGhhbmRsZSB0aGlzLl9fcnVubmluZyB0byBzdGFydCBhbmQgc3RvcCBwcm9wZXJseSB0aGUgc2NoZWR1bGVkIGVuZ2luZXNcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGxldCBuZXh0UG9zaXRpb24gPSBudWxsOyAvLyBJbmZpbml0eSAqIHNwZWVkOyAvLyBkZWZhdWx0IHJldHVyblxuXG4gICAgaWYgKHNwZWVkID4gMCkge1xuXG4gICAgICBpZiAocG9zaXRpb24gPCB0aGlzLl9fc3RhcnRQb3NpdGlvbikge1xuICAgICAgICAvLyBzeW5jIGVuZ2luZSBhdCBgX3N0YXJ0UG9zaXRpb25gXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHRoaXMuX19zdGFydFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICAvLyBzeW5jIGVuZ2luZSBhdCBgcG9zaXRpb25gXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIDApO1xuXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gSW5maW5pdHkgKiBzcGVlZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgc29tZWhvdyB0aGUgZW5naW5lIGFza2VkIHRvIGJlIGNhbGxlZCBhZnRlciBgZW5kUG9zaXRpb25gLCBjbGFtcCB2YWx1ZVxuICAgICAgaWYgKHRoaXMuX19pc1J1bm5pbmcgJiYgbmV4dFBvc2l0aW9uID4gdGhpcy5fX2VuZFBvc2l0aW9uKSB7XG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19lbmRQb3NpdGlvbjtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMuX19lbmRQb3NpdGlvbikge1xuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24gKyB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCB0aGlzLl9fZW5kUG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgMCk7XG5cbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBuZXh0UG9zaXRpb24gPSBJbmZpbml0eSAqIHNwZWVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBzb21laG93IHRoZSBlbmdpbmUgYXNrZWQgdG8gYmUgY2FsbGVkIGJlZm9yZSBgc3RhcnRQb3NpdGlvbmAsIGNsYW1wIHZhbHVlXG4gICAgICBpZiAodGhpcy5fX2lzUnVubmluZyAmJiBuZXh0UG9zaXRpb24gPCB0aGlzLl9fc3RhcnRQb3NpdGlvbikge1xuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgMCk7XG5cbiAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0UG9zaXRpb247XG4gIH1cblxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgLy8gY2VpbCBvciBmbG9vciBgcG9zaXRpb25gIGF0IDEwXi05IHRvIHByZXZlbnQgZmxvYXQgYXJpdGhtZXRpY3MgZXJyb3JzXG4gICAgLy8gdGhhdCBtYWtlIHRoZSB0cmFuc3BvcnRlZCBnbyB0byBpbmZpbml0ZSBsb29wc1xuICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5jZWlsKHBvc2l0aW9uICogMWU5KSAqIDFlLTk7XG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5mbG9vcihwb3NpdGlvbiAqIDFlOSkgKiAxZS05O1xuICAgIH1cblxuICAgIC8vIHN0b3AgZW5naW5lIGlmIG91dHNpZGUgYm91bmRhcmllc1xuICAgIGlmIChzcGVlZCA+IDAgJiYgcG9zaXRpb24gPj0gdGhpcy5fX2VuZFBvc2l0aW9uICYmIHRoaXMuX19pc1J1bm5pbmcpIHtcbiAgICAgIC8vIHN0b3AgZW5naW5lIGF0IF9fZW5kUG9zaXRpb25cbiAgICAgIHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHRoaXMuX19lbmRQb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgMCk7XG4gICAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkOyAvL1xuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX3N0YXJ0UG9zaXRpb24gJiYgdGhpcy5fX2lzUnVubmluZykge1xuICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgdGhpcy5fX3N0YXJ0UG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIDApO1xuICAgICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDsgLy9cbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgbmV4dCBwb3NpdGlvbiBhbmQgY2xhbXAgdG8gYm91bmRhcmllc1xuICAgIHBvc2l0aW9uID0gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcblxuICAgIC8vIHN0b3AgZW5naW5lIGlmIG91dHNpZGUgYm91bmRhcmllcyAtIHdpbGwgY2FsbCBhZHZhbmNlUG9zaXRpb24gb25jZSBtb3JlXG4gICAgLy8gYW5kIHRodXMgYHN5bmNQb3NpdGlvbmAgKGNmLiBsaW5lIDIxOCAtIDIyOClcbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uID4gdGhpcy5fX2VuZFBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX19lbmRQb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA8IHRoaXMuX19zdGFydFBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX19zdGFydFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpIHtcbiAgICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBvc2l0aW9uICs9IHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGhpcy5tYXN0ZXIuY3VycmVudFRpbWUsIHRoaXMubWFzdGVyLmN1cnJlbnRQb3NpdGlvbiwgMCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8vIFRyYW5zcG9ydGVkU3BlZWRDb250cm9sbGVkXG4vLyBoYXMgdG8gc3RhcnQgYW5kIHN0b3AgdGhlIHNwZWVkLWNvbnRyb2xsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxuY2xhc3MgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pIHtcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcbiAgfVxuXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgdHJ1ZSk7XG4gIH1cblxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIDApO1xuICB9XG5cbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxuICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGhpcy5tYXN0ZXIuY3VycmVudFRpbWUsIHRoaXMubWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgMCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8vIFRyYW5zcG9ydGVkU2NoZWR1bGVkXG4vLyBoYXMgdG8gc3dpdGNoIG9uIGFuZCBvZmYgdGhlIHNjaGVkdWxlZCBlbmdpbmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBoaXRzIHRoZSBlbmdpbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG5jbGFzcyBUcmFuc3BvcnRlZFNjaGVkdWxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xuICAgIHN1cGVyKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xuXG4gICAgLy8gc2NoZWR1bGluZyBxdWV1ZSBiZWNvbWVzIG1hc3RlciBvZiBlbmdpbmVcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsaW5nUXVldWUuYWRkKGVuZ2luZSwgSW5maW5pdHkpO1xuICB9XG5cbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVzZXRFbmdpbmVUaW1lKHRoaXMuX19lbmdpbmUsIHRpbWUpO1xuICB9XG5cbiAgc3RvcCh0aW1lLCBwb3NpdGlvbikge1xuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlc2V0RW5naW5lVGltZSh0aGlzLl9fZW5naW5lLCBJbmZpbml0eSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuLy8gdHJhbnNsYXRlcyBhZHZhbmNlUG9zaXRpb24gb2YgKnRyYW5zcG9ydGVkKiBlbmdpbmVzIGludG8gZ2xvYmFsIHNjaGVkdWxlciB0aW1lc1xuY2xhc3MgVHJhbnNwb3J0U2NoZWR1bGVySG9vayBleHRlbmRzIFRpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBJbmZpbml0eTtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlVGltZSh0aW1lKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX3RyYW5zcG9ydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb247XG4gICAgY29uc3Qgc3BlZWQgPSB0cmFuc3BvcnQuX19zcGVlZDtcbiAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0cmFuc3BvcnQuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgY29uc3QgbmV4dFRpbWUgPSB0cmFuc3BvcnQuX19nZXRUaW1lQXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbjtcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBuZXh0VGltZTtcblxuICAgIHJldHVybiBuZXh0VGltZTtcbiAgfVxuXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX3RyYW5zcG9ydDtcbiAgICBjb25zdCB0aW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xuXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX19uZXh0VGltZSA9IHRpbWU7XG5cbiAgICB0aGlzLnJlc2V0VGltZSh0aW1lKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IG51bGw7XG4gIH1cbn1cblxuLy8gaW50ZXJuYWwgc2NoZWR1bGluZyBxdWV1ZSB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgcG9zaXRpb24gKGFuZCB0aW1lKSBvZiB0aGUgdHJhbnNwb3J0XG5jbGFzcyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50VGltZTtcbiAgfVxuXG4gIGdldCBhdWRpb1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnQuYXVkaW9UaW1lO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50UG9zaXRpb247XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX190cmFuc3BvcnQuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMuX190cmFuc3BvcnQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXMgcG9zaXRpb24tYmFzZWQgc2NoZWR1bGluZyBvZiBUaW1lRW5naW5lIGluc3RhbmNlcy5cbiAqXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtbWFzdGVycy9tYXN0ZXIvZXhhbXBsZXMvdHJhbnNwb3J0L2luZGV4Lmh0bWx9XG4gKlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlZHVsZXIgLSBpbnN0YW5jZSBvZiBTY2hlZHVsZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbWFzdGVycyBmcm9tICd3YXZlcy1tYXN0ZXJzJztcbiAqXG4gKiBjb25zdCBnZXRUaW1lRnVuY3Rpb24gPSAoKSA9PiB7XG4gKiAgIGNvbnN0IG5vdyA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gKiAgIHJldHVybiBub3dbMF0gKyBub3dbMV0gKiAxZS05O1xuICogfVxuICogY29uc3Qgc2NoZWR1bGVyID0gbmV3IG1hc3RlcnMuU2NoZWR1bGVyKGdldFRpbWVGdW5jdGlvbik7XG4gKiBjb25zdCB0cmFuc3BvcnQgPSBuZXcgbWFzdGVycy5UcmFuc3BvcnQoc2NoZWR1bGVyKTtcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IG1hc3RlcnMuUGxheUNvbnRyb2woc2NoZWR1bGVyLCB0cmFuc3BvcnQpO1xuICogY29uc3QgbXlFbmdpbmUgPSBuZXcgTXlFbmdpbmUoKTtcbiAqIGNvbnN0IHlvdXJFbmdpbmUgPSBuZXcgeW91ckVuZ2luZSgpO1xuICpcbiAqIHRyYW5zcG9ydC5hZGQobXlFbmdpbmUpO1xuICogdHJhbnNwb3J0LmFkZCh5b3VyRW5naW5lKTtcbiAqXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xuICovXG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBUaW1lRW5naW5lIHtcbiAgY29uc3RydWN0b3Ioc2NoZWR1bGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKCFzY2hlZHVsZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgYHNjaGVkdWxlcmAsIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBgU2NoZWR1bGVyYCcpO1xuXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBbXTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWQgPSBbXTtcblxuICAgIHRoaXMuX19zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGVySG9vayh0aGlzKTtcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gICAgdGhpcy5fX3NjaGVkdWxpbmdRdWV1ZSA9IG5ldyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUodGhpcyk7XG5cbiAgICAvLyBzeW5jcm9uaXplZCB0aW1lLCBwb3NpdGlvbiwgYW5kIHNwZWVkXG4gICAgdGhpcy5fX3RpbWUgPSAwO1xuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fX3NwZWVkID0gMDtcbiAgfVxuXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5fX3NwZWVkID09PSAwKVxuICAgICAgcmV0dXJuICtJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5fX3RpbWUgKyAocG9zaXRpb24gLSB0aGlzLl9fcG9zaXRpb24pIC8gdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgX19nZXRQb3NpdGlvbkF0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xuICB9XG5cbiAgX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICBjb25zdCBudW1UcmFuc3BvcnRlZEVuZ2luZXMgPSB0aGlzLl9fdHJhbnNwb3J0ZWQubGVuZ3RoO1xuICAgIGxldCBuZXh0UG9zaXRpb24gPSBJbmZpbml0eSAqIHNwZWVkO1xuXG4gICAgaWYgKG51bVRyYW5zcG9ydGVkRW5naW5lcyA+IDApIHtcbiAgICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmNsZWFyKCk7XG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5yZXZlcnNlID0gKHNwZWVkIDwgMCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJhbnNwb3J0ZWRFbmdpbmVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3RyYW5zcG9ydGVkW2ldO1xuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSBlbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydChlbmdpbmUsIG5leHRFbmdpbmVQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLnRpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcbiAgfVxuXG4gIF9fc3luY1RyYW5zcG9ydGVkU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxuICAgICAgdHJhbnNwb3J0ZWQuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHRpbWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXG4gICAqIEBtZW1iZXJvZiBUcmFuc3BvcnRcbiAgICogQGluc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9fc2NoZWR1bGVyLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtYXN0ZXIgYXVkaW8gdGltZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQG5hbWUgY3VycmVudFRpbWVcbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYXVkaW9UaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9fc2NoZWR1bGVyLmF1ZGlvVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uIFRoaXMgZ2V0dGVyIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgdHJhbnNwb3J0XG4gICAqIGlzIGFkZGVkIHRvIGEgbWFzdGVyIChpLmUuIHRyYW5zcG9ydCBvciBwbGF5LWNvbnRyb2wpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAbmFtZSBjdXJyZW50UG9zaXRpb25cbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcblxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBuZXh0IHRyYW5zcG9ydCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV4dCAtIHRyYW5zcG9ydCBwb3NpdGlvblxuICAgKi9cbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xuXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSB0cmFuc3BvcnRlZCB0aW1lIGVuZ2luZSBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3BlZWRcbiAgICovXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZFxuICAgKi9cbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmhlYWQ7XG4gICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgIHJldHVybiB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhbnNwb3J0ZWQgdGltZSBlbmdpbmUgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NlZWs9ZmFsc2VdXG4gICAqL1xuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcbiAgICBjb25zdCBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XG5cbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCBzZWVrKSB7XG4gICAgICBsZXQgbmV4dFBvc2l0aW9uO1xuXG4gICAgICAvLyByZXN5bmMgdHJhbnNwb3J0ZWQgZW5naW5lc1xuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XG4gICAgICAgIC8vIHNlZWsgb3IgcmV2ZXJzZSBkaXJlY3Rpb25cbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xuICAgICAgICAvLyBzdGFydFxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gc3RvcFxuICAgICAgICBuZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXG4gICAgICAgIHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGltZSBlbmdpbmUgdG8gdGhlIHRyYW5zcG9ydC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVuZ2luZSAtIGVuZ2luZSB0byBiZSBhZGRlZCB0byB0aGUgdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIHN0YXJ0IHBvc2l0aW9uXG4gICAqL1xuICBhZGQoZW5naW5lLCBzdGFydFBvc2l0aW9uID0gMCwgZW5kUG9zaXRpb24gPSBJbmZpbml0eSwgb2Zmc2V0UG9zaXRpb24gPSAwKSB7XG4gICAgbGV0IHRyYW5zcG9ydGVkID0gbnVsbDtcblxuICAgIGlmIChvZmZzZXRQb3NpdGlvbiA9PT0gLUluZmluaXR5KVxuICAgICAgb2Zmc2V0UG9zaXRpb24gPSAwO1xuXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcblxuICAgIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpKVxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU3BlZWRDb250cm9sbGVkKGVuZ2luZSkpXG4gICAgICB0cmFuc3BvcnRlZCA9IG5ldyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXG4gICAgICB0cmFuc3BvcnRlZCA9IG5ldyBUcmFuc3BvcnRlZFNjaGVkdWxlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBhIHRyYW5zcG9ydFwiKTtcblxuICAgIGlmICh0cmFuc3BvcnRlZCkge1xuICAgICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XG5cbiAgICAgIGFkZER1cGxldCh0aGlzLl9fZW5naW5lcywgdGhpcy5fX3RyYW5zcG9ydGVkLCBlbmdpbmUsIHRyYW5zcG9ydGVkKTtcblxuICAgICAgaWYgKHNwZWVkICE9PSAwKSB7XG4gICAgICAgIC8vIHN5bmMgYW5kIHN0YXJ0XG4gICAgICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IHRyYW5zcG9ydGVkLnN5bmNQb3NpdGlvbih0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgc3BlZWQpO1xuICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5pbnNlcnQodHJhbnNwb3J0ZWQsIG5leHRFbmdpbmVQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zcG9ydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHRpbWUgZW5naW5lIGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGVuZ2luZU9yVHJhbnNwb3J0ZWQgLSBlbmdpbmUgb3IgdHJhbnNwb3J0ZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSB0cmFuc3BvcnRcbiAgICovXG4gIHJlbW92ZShlbmdpbmVPclRyYW5zcG9ydGVkKSB7XG4gICAgbGV0IGVuZ2luZSA9IGVuZ2luZU9yVHJhbnNwb3J0ZWQ7XG4gICAgbGV0IHRyYW5zcG9ydGVkID0gcmVtb3ZlRHVwbGV0KHRoaXMuX19lbmdpbmVzLCB0aGlzLl9fdHJhbnNwb3J0ZWQsIGVuZ2luZU9yVHJhbnNwb3J0ZWQpO1xuXG4gICAgaWYgKCF0cmFuc3BvcnRlZCkge1xuICAgICAgZW5naW5lID0gcmVtb3ZlRHVwbGV0KHRoaXMuX190cmFuc3BvcnRlZCwgdGhpcy5fX2VuZ2luZXMsIGVuZ2luZU9yVHJhbnNwb3J0ZWQpO1xuICAgICAgdHJhbnNwb3J0ZWQgPSBlbmdpbmVPclRyYW5zcG9ydGVkO1xuICAgIH1cblxuICAgIGlmIChlbmdpbmUgJiYgdHJhbnNwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLnJlbW92ZSh0cmFuc3BvcnRlZCk7XG5cbiAgICAgIHRyYW5zcG9ydGVkLmRlc3Ryb3koKTtcblxuICAgICAgaWYgKHRoaXMuX19zcGVlZCAhPT0gMClcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhpcyB0cmFuc3BvcnRcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBlbmdpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gdHJhbnNwb3J0ZWQgLSBFbmdpbmUgdG8gcmVzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gTmV3IHBvc2l0aW9uXG4gICAqL1xuICByZXNldEVuZ2luZVBvc2l0aW9uKHRyYW5zcG9ydGVkLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5fX3NwZWVkO1xuXG4gICAgaWYgKHNwZWVkICE9PSAwKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZClcbiAgICAgICAgcG9zaXRpb24gPSB0cmFuc3BvcnRlZC5zeW5jUG9zaXRpb24odGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIHNwZWVkKTtcblxuICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IG51bGw7XG5cbiAgICAgIC8vIHRoZSBwcmlvcml0eSBxdWV1ZSBkb2VzIG5vdCBrZWVwIHRyYWNrIG9mIHRoZSBlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgLy8gaW5zZXJ0ZWQgYXQgSW5maW5pdHksIHNvIHdlIG5lZWQgdG8gcmVpbnNlcnQgdHJhbnNwb3J0ZWQgZW5naW5lIGluXG4gICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAvLyBAbm90ZSAtIHRoaXMgY291bGQgcHJvYmFibHkgYmUgbW9yZSBjbGVhblxuICAgICAgLy8gICAgICAgLSBwcm9iYWJseSB0aGUgcHJpb3JpdHkgcXVldWUgc2hvdWxkIGtlZXAgdGhlc2UgcmVmZXJlbmNlc1xuICAgICAgaWYgKCF0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5oYXModHJhbnNwb3J0ZWQpKSB7XG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydCh0cmFuc3BvcnRlZCwgcG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUubW92ZSh0cmFuc3BvcnRlZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0aW1lIGVuZ2luZXMgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zeW5jU3BlZWQodGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIDApO1xuXG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxuICAgICAgdHJhbnNwb3J0ZWQuZGVzdHJveSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydDtcbiJdfQ==