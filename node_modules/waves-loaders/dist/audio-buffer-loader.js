'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise2 = require('babel-runtime/core-js/promise');

var _promise3 = _interopRequireDefault(_promise2);

var _loader = require('./loader');

var _loader2 = _interopRequireDefault(_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AudioContext = window.AudioContext || window.webkitAudioContext;

if (!AudioContext) throw new Error('WebAudio API not supported');

var audioContext = new AudioContext();

var silentBuffer = new Uint32Array([0x46464952, 0x00000038, 0x45564157, 0x20746d66, 0x00000010, 0x00010001, 0x0000ac44, 0x00015888, 0x00100002, 0x61746164, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]).buffer;

var noop = function noop() {};

// @todo - review to allow to use external audioContext
var _decodeAudioData = audioContext.decodeAudioData;
var promise = audioContext.decodeAudioData(silentBuffer, noop, noop);
// implement non promised base decode audio data
if (!promise) {
  _decodeAudioData = function decodeAudioData(arraybuffer) {
    return new _promise3.default(function (resolve, reject) {
      audioContext.decodeAudioData(arraybuffer, function (buffer) {
        resolve(buffer);
      }, function (err) {
        reject(new Error('Unable to decode audio data'));
      });
    });
  };
}

/**
 * AudioBufferLoader
 * Promise based implementation of XMLHttpRequest Level 2 for GET method and
 * decode audio data for arraybuffer.
 */

var AudioBufferLoader = function (_Loader) {
  (0, _inherits3.default)(AudioBufferLoader, _Loader);

  /**
   * Set the responseType to 'arraybuffer' and initialize options.
   * @param {string} [responseType="arraybuffer"]
   */
  function AudioBufferLoader() {
    var responseType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'arraybuffer';
    (0, _classCallCheck3.default)(this, AudioBufferLoader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioBufferLoader.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferLoader)).call(this, responseType));

    _this.options = { wrapAroundExtension: 0 };
    _this.responseType = responseType;
    _this.audioContext = audioContext;

    _this.decodeAudioData = _this.decodeAudioData.bind(_this);
    return _this;
  }

  /**
   * Allow to set the audio context that should be used in order to decode
   * the file and create the AudioBuffer.
   * @param {AudioContext} audioContext
   */


  (0, _createClass3.default)(AudioBufferLoader, [{
    key: 'setAudioContext',
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }

    /**
     * Method for promise audio file loading and decoding.
     * @param {(string|string[])} fileURLs - The URL(s) of the audio files to load.
     *  Accepts a URL pointing to the file location or an array of URLs.
     * @param {{wrapAroundExtension: number}} [options] - Object with a
     *  wrapAroundExtension key which set the length, in seconds to be copied from
     *  the begining at the end of the returned AudioBuffer
     * @returns {Promise}
     */

  }, {
    key: 'load',
    value: function load(fileURLs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.options = options;
      this.options.wrapAroundExtension = this.options.wrapAroundExtension || 0;

      return (0, _get3.default)(AudioBufferLoader.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'load', this).call(this, fileURLs);
    }

    /**
     * Load a single audio file, decode it in an AudioBuffer, return a Promise
     * @private
     * @param {string} fileURL - The URL of the audio file location to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadOne',
    value: function loadOne(fileURL) {
      var _this2 = this;

      return (0, _get3.default)(AudioBufferLoader.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadOne', this).call(this, fileURL).then(function (arraybuffer) {
        return _this2.decodeAudioData(arraybuffer, fileURL);
      }).catch(function (err) {
        throw err;
      });
    }

    /**
     * Load all audio files at once in a single array, decode them in an array of
     * AudioBuffers, and return a Promise.
     * @private
     * @param {string[]} fileURLs - The URLs array of the audio files to load.
     * @returns {Promise}
     */

  }, {
    key: 'loadAll',
    value: function loadAll(fileURLs) {
      var _this3 = this;

      return (0, _get3.default)(AudioBufferLoader.prototype.__proto__ || (0, _getPrototypeOf2.default)(AudioBufferLoader.prototype), 'loadAll', this).call(this, fileURLs).then(function (arraybuffers) {
        var promises = arraybuffers.map(function (arraybuffer, index) {
          var fileURL = fileURLs[index];
          return _this3.decodeAudioData(arraybuffer, fileURL);
        });

        return _promise3.default.all(promises);
      }).catch(function (err) {
        throw err;
      });
    }

    /**
     * Decode Audio Data, return a Promise
     * @private
     * @param {arraybuffer} - The arraybuffer of the loaded audio file to be decoded.
     * @returns {Promise}
     */

  }, {
    key: 'decodeAudioData',
    value: function decodeAudioData(arraybuffer, fileURL) {
      var _this4 = this;

      if (arraybuffer instanceof ArrayBuffer) {
        var _promise = _decodeAudioData.call(audioContext, arraybuffer);

        _promise.then(function (buffer) {
          if (_this4.options.wrapAroundExtension !== 0) buffer = _this4.__wrapAround(buffer);

          return _promise3.default.resolve(buffer);
        }).catch(function (err) {
          throw new Error('Unable to decode file ' + fileURL);
        });

        return _promise;
      } else {
        return _promise3.default.resolve(arraybuffer);
      }
    }

    /**
     * WrapAround, copy the begining input buffer to the end of an output buffer
     * @private
     * @param {arraybuffer} inBuffer {arraybuffer} - The input buffer
     * @returns {arraybuffer} - The processed buffer (with frame copied from the begining to the end)
     */

  }, {
    key: '__wrapAround',
    value: function __wrapAround(inBuffer) {
      var numberOfChannels = inBuffer.numberOfChannels,
          sampleRate = inBuffer.sampleRate,
          length = inBuffer.length;

      var outLength = length + this.options.wrapAroundExtension * sampleRate;
      var outBuffer = this.audioContext.createBuffer(numberOfChannels, outLength, sampleRate);

      for (var channel = 0; channel < numberOfChannels; channel++) {
        var channelData = inBuffer.getChannelData(channel);
        var outData = outBuffer.getChannelData(channel);
        var inLength = inBuffer.length;

        for (var i = 0; i < outLength; i++) {
          if (i < inLength) outData[i] = channelData[i];else outData[i] = channelData[i - inLength];
        }
      }

      return outBuffer;
    }
  }]);
  return AudioBufferLoader;
}(_loader2.default);

exports.default = AudioBufferLoader;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF1ZGlvLWJ1ZmZlci1sb2FkZXIuanMiXSwibmFtZXMiOlsiQXVkaW9Db250ZXh0Iiwid2luZG93Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiRXJyb3IiLCJhdWRpb0NvbnRleHQiLCJzaWxlbnRCdWZmZXIiLCJVaW50MzJBcnJheSIsImJ1ZmZlciIsIm5vb3AiLCJkZWNvZGVBdWRpb0RhdGEiLCJwcm9taXNlIiwiYXJyYXlidWZmZXIiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyIiwiQXVkaW9CdWZmZXJMb2FkZXIiLCJyZXNwb25zZVR5cGUiLCJvcHRpb25zIiwid3JhcEFyb3VuZEV4dGVuc2lvbiIsImJpbmQiLCJmaWxlVVJMcyIsImZpbGVVUkwiLCJ0aGVuIiwiY2F0Y2giLCJhcnJheWJ1ZmZlcnMiLCJwcm9taXNlcyIsIm1hcCIsImluZGV4IiwiYWxsIiwiQXJyYXlCdWZmZXIiLCJjYWxsIiwiX193cmFwQXJvdW5kIiwiaW5CdWZmZXIiLCJudW1iZXJPZkNoYW5uZWxzIiwic2FtcGxlUmF0ZSIsImxlbmd0aCIsIm91dExlbmd0aCIsIm91dEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImNoYW5uZWwiLCJjaGFubmVsRGF0YSIsImdldENoYW5uZWxEYXRhIiwib3V0RGF0YSIsImluTGVuZ3RoIiwiaSIsIkxvYWRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFFQSxJQUFNQSxlQUFnQkMsT0FBT0QsWUFBUCxJQUF1QkMsT0FBT0Msa0JBQXBEOztBQUVBLElBQUksQ0FBQ0YsWUFBTCxFQUNFLE1BQU0sSUFBSUcsS0FBSixDQUFVLDRCQUFWLENBQU47O0FBRUYsSUFBTUMsZUFBZSxJQUFJSixZQUFKLEVBQXJCOztBQUVBLElBQU1LLGVBQWUsSUFBSUMsV0FBSixDQUFnQixDQUNuQyxVQURtQyxFQUN2QixVQUR1QixFQUNYLFVBRFcsRUFDQyxVQURELEVBRW5DLFVBRm1DLEVBRXZCLFVBRnVCLEVB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QixDQUFwQjtBQUNBLFlBQU1HLFVBQVVMLFVBQVVJLGNBQVYsQ0FBeUJGLE9BQXpCLENBQWhCO0FBQ0EsWUFBTUksV0FBV1gsU0FBU0csTUFBMUI7O0FBRUEsYUFBSyxJQUFJUyxJQUFJLENBQWIsRUFBZ0JBLElBQUlSLFNBQXBCLEVBQStCUSxHQUEvQixFQUFvQztBQUNsQyxjQUFJQSxJQUFJRCxRQUFSLEVBQ0VELFFBQVFFLENBQVIsSUFBYUosWUFBWUksQ0FBWixDQUFiLENBREYsS0FHRUYsUUFBUUUsQ0FBUixJQUFhSixZQUFZSSxJQUFJRCxRQUFoQixDQUFiO0FBQ0g7QUFDRjs7QUFFRCxhQUFPTixTQUFQO0FBQ0Q7OztFQTVINENRLGdCOztrQkFBMUI5QixpQiIsImZpbGUiOiJhdWRpby1idWZmZXItbG9hZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvYWRlciBmcm9tICcuL2xvYWRlcic7XG5cbmNvbnN0IEF1ZGlvQ29udGV4dCA9ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuXG5pZiAoIUF1ZGlvQ29udGV4dClcbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBdWRpbyBBUEkgbm90IHN1cHBvcnRlZCcpO1xuXG5jb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG5cbmNvbnN0IHNpbGVudEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NDY0NjQ5NTIsIDB4MDAwMDAwMzgsIDB4NDU1NjQxNTcsIDB4MjA3NDZkNjYsXG4gIDB4MDAwMDAwMTAsIDB4MDAwMTAwMDEsIDB4MDAwMGFjNDQsIDB4MDAwMTU4ODgsXG4gIDB4MDAxMDAwMDIsIDB4NjE3NDYxNjQsIDB4MDAwMDAwMTQsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG5dKS5idWZmZXI7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gQHRvZG8gLSByZXZpZXcgdG8gYWxsb3cgdG8gdXNlIGV4dGVybmFsIGF1ZGlvQ29udGV4dFxubGV0IGRlY29kZUF1ZGlvRGF0YSA9IGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGE7XG5jb25zdCBwcm9taXNlID0gYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShzaWxlbnRCdWZmZXIsIG5vb3AsIG5vb3ApO1xuLy8gaW1wbGVtZW50IG5vbiBwcm9taXNlZCBiYXNlIGRlY29kZSBhdWRpbyBkYXRhXG5pZiAoIXByb21pc2UpIHtcbiAgZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCAoYnVmZmVyKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYnVmZmVyKTtcbiAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY29kZSBhdWRpbyBkYXRhJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEF1ZGlvQnVmZmVyTG9hZGVyXG4gKiBQcm9taXNlIGJhc2VkIGltcGxlbWVudGF0aW9uIG9mIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZm9yIEdFVCBtZXRob2QgYW5kXG4gKiBkZWNvZGUgYXVkaW8gZGF0YSBmb3IgYXJyYXlidWZmZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvQnVmZmVyTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgLyoqXG4gICAqIFNldCB0aGUgcmVzcG9uc2VUeXBlIHRvICdhcnJheWJ1ZmZlcicgYW5kIGluaXRpYWxpemUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiXVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJykge1xuICAgIHN1cGVyKHJlc3BvbnNlVHlwZSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7IHdyYXBBcm91bmRFeHRlbnNpb246IDAgfTtcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcblxuICAgIHRoaXMuZGVjb2RlQXVkaW9EYXRhID0gdGhpcy5kZWNvZGVBdWRpb0RhdGEuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyB0byBzZXQgdGhlIGF1ZGlvIGNvbnRleHQgdGhhdCBzaG91bGQgYmUgdXNlZCBpbiBvcmRlciB0byBkZWNvZGVcbiAgICogdGhlIGZpbGUgYW5kIGNyZWF0ZSB0aGUgQXVkaW9CdWZmZXIuXG4gICAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBhdWRpb0NvbnRleHRcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHByb21pc2UgYXVkaW8gZmlsZSBsb2FkaW5nIGFuZCBkZWNvZGluZy5cbiAgICogQHBhcmFtIHsoc3RyaW5nfHN0cmluZ1tdKX0gZmlsZVVSTHMgLSBUaGUgVVJMKHMpIG9mIHRoZSBhdWRpbyBmaWxlcyB0byBsb2FkLlxuICAgKiAgQWNjZXB0cyBhIFVSTCBwb2ludGluZyB0byB0aGUgZmlsZSBsb2NhdGlvbiBvciBhbiBhcnJheSBvZiBVUkxzLlxuICAgKiBAcGFyYW0ge3t3cmFwQXJvdW5kRXh0ZW5zaW9uOiBudW1iZXJ9fSBbb3B0aW9uc10gLSBPYmplY3Qgd2l0aCBhXG4gICAqICB3cmFwQXJvdW5kRXh0ZW5zaW9uIGtleSB3aGljaCBzZXQgdGhlIGxlbmd0aCwgaW4gc2Vjb25kcyB0byBiZSBjb3BpZWQgZnJvbVxuICAgKiAgdGhlIGJlZ2luaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJldHVybmVkIEF1ZGlvQnVmZmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZChmaWxlVVJMcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uIHx8IDA7XG5cbiAgICByZXR1cm4gc3VwZXIubG9hZChmaWxlVVJMcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHNpbmdsZSBhdWRpbyBmaWxlLCBkZWNvZGUgaXQgaW4gYW4gQXVkaW9CdWZmZXIsIHJldHVybiBhIFByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVVUkwgLSBUaGUgVVJMIG9mIHRoZSBhdWRpbyBmaWxlIGxvY2F0aW9uIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZE9uZShmaWxlVVJMKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxvYWRPbmUoZmlsZVVSTClcbiAgICAgIC50aGVuKGFycmF5YnVmZmVyID0+IHRoaXMuZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCBmaWxlVVJMKSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7IHRocm93IGVycjsgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgYXVkaW8gZmlsZXMgYXQgb25jZSBpbiBhIHNpbmdsZSBhcnJheSwgZGVjb2RlIHRoZW0gaW4gYW4gYXJyYXkgb2ZcbiAgICogQXVkaW9CdWZmZXJzLCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmlsZVVSTHMgLSBUaGUgVVJMcyBhcnJheSBvZiB0aGUgYXVkaW8gZmlsZXMgdG8gbG9hZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkQWxsKGZpbGVVUkxzKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxvYWRBbGwoZmlsZVVSTHMpXG4gICAgICAudGhlbigoYXJyYXlidWZmZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gYXJyYXlidWZmZXJzLm1hcCgoYXJyYXlidWZmZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZVVSTCA9IGZpbGVVUkxzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIsIGZpbGVVUkwpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7IHRocm93IGVycjsgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIEF1ZGlvIERhdGEsIHJldHVybiBhIFByb21pc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHthcnJheWJ1ZmZlcn0gLSBUaGUgYXJyYXlidWZmZXIgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGJlIGRlY29kZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCBmaWxlVVJMKSB7XG4gICAgaWYgKGFycmF5YnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBkZWNvZGVBdWRpb0RhdGEuY2FsbChhdWRpb0NvbnRleHQsIGFycmF5YnVmZmVyKVxuXG4gICAgICBwcm9taXNlXG4gICAgICAgIC50aGVuKChidWZmZXIpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24gIT09IDApXG4gICAgICAgICAgICBidWZmZXIgPSB0aGlzLl9fd3JhcEFyb3VuZChidWZmZXIpO1xuXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShidWZmZXIpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGRlY29kZSBmaWxlICR7ZmlsZVVSTH1gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFycmF5YnVmZmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcEFyb3VuZCwgY29weSB0aGUgYmVnaW5pbmcgaW5wdXQgYnVmZmVyIHRvIHRoZSBlbmQgb2YgYW4gb3V0cHV0IGJ1ZmZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2FycmF5YnVmZmVyfSBpbkJ1ZmZlciB7YXJyYXlidWZmZXJ9IC0gVGhlIGlucHV0IGJ1ZmZlclxuICAgKiBAcmV0dXJucyB7YXJyYXlidWZmZXJ9IC0gVGhlIHByb2Nlc3NlZCBidWZmZXIgKHdpdGggZnJhbWUgY29waWVkIGZyb20gdGhlIGJlZ2luaW5nIHRvIHRoZSBlbmQpXG4gICAqL1xuICBfX3dyYXBBcm91bmQoaW5CdWZmZXIpIHtcbiAgICBjb25zdCB7IG51bWJlck9mQ2hhbm5lbHMsIHNhbXBsZVJhdGUsIGxlbmd0aCB9ID0gaW5CdWZmZXI7XG4gICAgY29uc3Qgb3V0TGVuZ3RoID0gbGVuZ3RoICsgdGhpcy5vcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24gKiBzYW1wbGVSYXRlO1xuICAgIGNvbnN0IG91dEJ1ZmZlciA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcihudW1iZXJPZkNoYW5uZWxzLCBvdXRMZW5ndGgsIHNhbXBsZVJhdGUpO1xuXG4gICAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBudW1iZXJPZkNoYW5uZWxzOyBjaGFubmVsKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWxEYXRhID0gaW5CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG4gICAgICBjb25zdCBvdXREYXRhID0gb3V0QnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xuICAgICAgY29uc3QgaW5MZW5ndGggPSBpbkJ1ZmZlci5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCBpbkxlbmd0aClcbiAgICAgICAgICBvdXREYXRhW2ldID0gY2hhbm5lbERhdGFbaV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXREYXRhW2ldID0gY2hhbm5lbERhdGFbaSAtIGluTGVuZ3RoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0QnVmZmVyO1xuICB9XG59XG4iXX0=