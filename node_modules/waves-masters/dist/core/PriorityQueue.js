"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlByaW9yaXR5UXVldWUuanMiXSwibmFtZXMiOlsic3dhcCIsImFyciIsImkxIiwiaTIiLCJ0bXAiLCJpbmRleE9mIiwiZWwiLCJsIiwibGVuZ3RoIiwiaSIsIl9pc0xvd2VyTWF4SGVhcCIsInRpbWUxIiwidGltZTIiLCJfaXNMb3dlck1pbkhlYXAiLCJfaXNIaWdoZXJNYXhIZWFwIiwiX2lzSGlnaGVyTWluSGVhcCIsIlBPU0lUSVZFX0lORklOSVRZIiwiTnVtYmVyIiwiUHJpb3JpdHlRdWV1ZSIsImhlYXBMZW5ndGgiLCJfY3VycmVudExlbmd0aCIsIl9oZWFwIiwiQXJyYXkiLCJfcmV2ZXJzZSIsInJldmVyc2UiLCJzdGFydEluZGV4IiwiZW50cnkiLCJpbmRleCIsInBhcmVudEluZGV4IiwiTWF0aCIsImZsb29yIiwicGFyZW50IiwiX2lzSGlnaGVyIiwicXVldWVUaW1lIiwiYzFpbmRleCIsImMyaW5kZXgiLCJjaGlsZDEiLCJjaGlsZDIiLCJfaXNMb3dlciIsInRhcmdldEluZGV4IiwibWF4SW5kZXgiLCJfYnViYmxlRG93biIsInRpbWUiLCJhYnMiLCJfYnViYmxlVXAiLCJ1bmRlZmluZWQiLCJyZW1vdmUiLCJsYXN0SW5kZXgiLCJJbmZpbml0eSIsInZhbHVlIiwiYnVpbGRIZWFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxTQUFTQSxJQUFULENBQWNDLEdBQWQsRUFBbUJDLEVBQW5CLEVBQXVCQyxFQUF2QixFQUEyQjtBQUN6QixNQUFNQyxNQUFNSCxJQUFJQyxFQUFKLENBQVo7QUFDQUQsTUFBSUMsRUFBSixJQUFVRCxJQUFJRSxFQUFKLENBQVY7QUFDQUYsTUFBSUUsRUFBSixJQUFVQyxHQUFWO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTQyxPQUFULENBQWlCSixHQUFqQixFQUFzQkssRUFBdEIsRUFBMEI7QUFDeEIsTUFBTUMsSUFBSU4sSUFBSU8sTUFBZDtBQUNBO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFB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QUFDTCxlQUFLd0IsUUFBTCxHQUFnQnpCLGVBQWhCO0FBQ0EsZUFBS21CLFNBQUwsR0FBaUJqQixnQkFBakI7QUFDRDs7QUFFRCxhQUFLbUMsU0FBTDtBQUNEO0FBQ0YsSzt3QkFFYTtBQUNaLGFBQU8sS0FBSzNCLFFBQVo7QUFDRDs7Ozs7a0JBZ01ZTCxhIiwiZmlsZSI6IlByaW9yaXR5UXVldWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3b3JrcyBieSByZWZlcmVuY2VcbmZ1bmN0aW9uIHN3YXAoYXJyLCBpMSwgaTIpIHtcbiAgY29uc3QgdG1wID0gYXJyW2kxXTtcbiAgYXJyW2kxXSA9IGFycltpMl07XG4gIGFycltpMl0gPSB0bXA7XG59XG5cbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9qcy1mb3ItbG9vcC12cy1hcnJheS1pbmRleG9mLzM0NlxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIGVsKSB7XG4gIGNvbnN0IGwgPSBhcnIubGVuZ3RoO1xuICAvLyBpZ25vcmUgZmlyc3QgZWxlbWVudCBhcyBpdCBjYW4ndCBiZSBhIGVudHJ5XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWwpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgaWYgYHRpbWUxYCBzaG91bGQgYmUgbG93ZXIgaW4gdGhlIHRvcG9ncmFwaHkgdGhhbiBgdGltZTJgLlxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBfaXNMb3dlck1heEhlYXAgPSBmdW5jdGlvbih0aW1lMSwgdGltZTIpIHtcbiAgcmV0dXJuIHRpbWUxIDwgdGltZTI7XG59O1xuXG5jb25zdCBfaXNMb3dlck1pbkhlYXAgPSBmdW5jdGlvbih0aW1lMSwgdGltZTIpIHtcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XG59O1xuXG4vKipcbiAqIERlZmluZSBpZiBgdGltZTFgIHNob3VsZCBiZSBoaWdoZXIgaW4gdGhlIHRvcG9ncmFwaHkgdGhhbiBgdGltZTJgLlxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBfaXNIaWdoZXJNYXhIZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XG4gIHJldHVybiB0aW1lMSA+IHRpbWUyO1xufTtcblxuY29uc3QgX2lzSGlnaGVyTWluSGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xuICByZXR1cm4gdGltZTEgPCB0aW1lMjtcbn07XG5cbmNvbnN0IFBPU0lUSVZFX0lORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4vKipcbiAqIFByaW9yaXR5IHF1ZXVlIGltcGxlbWVudGluZyBhIGJpbmFyeSBoZWFwLlxuICogQWN0cyBhcyBhIG1pbiBoZWFwIGJ5IGRlZmF1bHQsIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkIHRvIGEgbWF4IGhlYXBcbiAqIGJ5IHNldHRpbmcgYHJldmVyc2VgIHRvIHRydWUuXG4gKlxuICogX25vdGVfOiB0aGUgcXVldWUgY3JlYXRlcyBhbmQgbWFpbnRhaW5zIGEgbmV3IHByb3BlcnR5IChpLmUuIGBxdWV1ZVRpbWVgKVxuICogdG8gZWFjaCBvYmplY3QgYWRkZWQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWFwTGVuZ3RoPTEwMF0gLSBEZWZhdWx0IHNpemUgb2YgdGhlIGFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBoZWFwLlxuICovXG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgY29uc3RydWN0b3IoaGVhcExlbmd0aCA9IDEwMCkge1xuICAgIC8qKlxuICAgICAqIFBvaW50ZXIgdG8gdGhlIGZpcnN0IGVtcHR5IGluZGV4IG9mIHRoZSBoZWFwLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIFByaW9yaXR5UXVldWVcbiAgICAgKiBAbmFtZSBfY3VycmVudExlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiB0aGUgc29ydGVkIGluZGV4ZXMgb2YgdGhlIGVudHJpZXMsIHRoZSBhY3R1YWwgaGVhcC4gSWdub3JlIHRoZSBpbmRleCAwLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxuICAgICAqIEBuYW1lIF9oZWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5KGhlYXBMZW5ndGggKyAxKTtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgdGhlIHF1ZXVlOiBgbWluYCBoZWFwIGlmIGBmYWxzZWAsIGBtYXhgIGhlYXAgaWYgYHRydWVgXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIFByaW9yaXR5UXVldWVcbiAgICAgKiBAbmFtZSBfcmV2ZXJzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmV2ZXJzZSA9IG51bGw7XG5cbiAgICAvLyBpbml0aWFsaXplIGNvbXBhcmUgZnVuY3Rpb25zXG4gICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGltZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdGltZSgpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudExlbmd0aCA+IDEpXG4gICAgICByZXR1cm4gdGhpcy5faGVhcFsxXS5xdWV1ZVRpbWU7XG5cbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cblxuICAvKipcbiAgICogRmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGhlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYXBbMV07XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgcXVldWUgKG1heCBoZWFwIGlmIHRydWUsIG1pbiBoZWFwIGlmIGZhbHNlKSxcbiAgICogcmVidWlsZCB0aGUgaGVhcCB3aXRoIHRoZSBleGlzdGluZyBlbnRyaWVzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNldCByZXZlcnNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9yZXZlcnNlKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXZlcnNlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1heEhlYXA7XG4gICAgICAgIHRoaXMuX2lzSGlnaGVyID0gX2lzSGlnaGVyTWF4SGVhcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1pbkhlYXA7XG4gICAgICAgIHRoaXMuX2lzSGlnaGVyID0gX2lzSGlnaGVyTWluSGVhcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZEhlYXAoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcmV2ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIGhlYXAgYnkgbW92aW5nIGFuIGVudHJ5IHRvIGEgbmV3IHVwcGVyIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZW50cnkgdG8gbW92ZS5cbiAgICovXG4gIF9idWJibGVVcChzdGFydEluZGV4KSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5faGVhcFtzdGFydEluZGV4XTtcblxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgbGV0IHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgdGhpcy5faXNIaWdoZXIoZW50cnkucXVldWVUaW1lLCBwYXJlbnQucXVldWVUaW1lKSkge1xuICAgICAgc3dhcCh0aGlzLl9oZWFwLCBpbmRleCwgcGFyZW50SW5kZXgpO1xuXG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRml4IHRoZSBoZWFwIGJ5IG1vdmluZyBhbiBlbnRyeSB0byBhIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGVudHJ5IHRvIG1vdmUuXG4gICAqL1xuICBfYnViYmxlRG93bihzdGFydEluZGV4KSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5faGVhcFtzdGFydEluZGV4XTtcblxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgbGV0IGMxaW5kZXggPSBpbmRleCAqIDI7XG4gICAgbGV0IGMyaW5kZXggPSBjMWluZGV4ICsgMTtcbiAgICBsZXQgY2hpbGQxID0gdGhpcy5faGVhcFtjMWluZGV4XTtcbiAgICBsZXQgY2hpbGQyID0gdGhpcy5faGVhcFtjMmluZGV4XTtcblxuICAgIHdoaWxlICgoY2hpbGQxICYmIHRoaXMuX2lzTG93ZXIoZW50cnkucXVldWVUaW1lLCBjaGlsZDEucXVldWVUaW1lKSnCoHx8XG4gICAgICAgICAgIChjaGlsZDIgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMi5xdWV1ZVRpbWUpKSlcbiAgICB7XG4gICAgICAvLyBzd2FwIHdpdGggdGhlIG1pbmltdW0gY2hpbGRcbiAgICAgIGxldCB0YXJnZXRJbmRleDtcblxuICAgICAgaWYgKGNoaWxkMilcbiAgICAgICAgdGFyZ2V0SW5kZXggPSB0aGlzLl9pc0hpZ2hlcihjaGlsZDEucXVldWVUaW1lLCBjaGlsZDIucXVldWVUaW1lKSA/IGMxaW5kZXggOiBjMmluZGV4O1xuICAgICAgZWxzZVxuICAgICAgICB0YXJnZXRJbmRleCA9IGMxaW5kZXg7XG5cbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHRhcmdldEluZGV4KTtcblxuICAgICAgLy8gdXBkYXRlIHRvIGZpbmQgbmV4dCBjaGlsZHJlblxuICAgICAgaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIGMxaW5kZXggPSBpbmRleCAqIDI7XG4gICAgICBjMmluZGV4ID0gYzFpbmRleCArIDE7XG4gICAgICBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xuICAgICAgY2hpbGQyID0gdGhpcy5faGVhcFtjMmluZGV4XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgdGhlIGhlYXAgKGZyb20gYm90dG9tIHVwKS5cbiAgICovXG4gIGJ1aWxkSGVhcCgpIHtcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbnRlcm5hbCBub2RlXG4gICAgLy8gQHRvZG8gLSBtYWtlIHN1cmUgdGhhdCdzIHRoZSByaWdodCB3YXkgdG8gZG8uXG4gICAgbGV0IG1heEluZGV4ID0gTWF0aC5mbG9vcigodGhpcy5fY3VycmVudExlbmd0aCAtIDEpIC8gMik7XG5cbiAgICBmb3IgKGxldCBpID0gbWF4SW5kZXg7IGkgPiAwOyBpLS0pXG4gICAgICB0aGlzLl9idWJibGVEb3duKGkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIG5ldyBvYmplY3QgaW4gdGhlIGJpbmFyeSBoZWFwIGFuZCBzb3J0IGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBFbnRyeSB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGltZSBvZiB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGhlYXAuXG4gICAqL1xuICBpbnNlcnQoZW50cnksIHRpbWUpIHtcbiAgICBpZiAoTWF0aC5hYnModGltZSkgIT09IFBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xuICAgICAgLy8gYWRkIHRoZSBuZXcgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgaGVhcFxuICAgICAgdGhpcy5faGVhcFt0aGlzLl9jdXJyZW50TGVuZ3RoXSA9IGVudHJ5O1xuICAgICAgLy8gYnViYmxlIGl0IHVwXG4gICAgICB0aGlzLl9idWJibGVVcCh0aGlzLl9jdXJyZW50TGVuZ3RoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggKz0gMTtcblxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcbiAgICB9XG5cbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlKGVudHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZ2l2ZW4gZW50cnkgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIG1vdmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBUaW1lIG9mIGZpcnN0IGVudHJ5IGluIHRoZSBoZWFwLlxuICAgKi9cbiAgbW92ZShlbnRyeSwgdGltZSkge1xuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5kZXhPZih0aGlzLl9oZWFwLCBlbnRyeSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZW50cnkucXVldWVUaW1lID0gdGltZTtcbiAgICAgICAgLy8gZGVmaW5lIGlmIHRoZSBlbnRyeSBzaG91bGQgYmUgYnViYmxlZCB1cCBvciBkb3duXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcblxuICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKHRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKVxuICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2J1YmJsZURvd24oaW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH1cblxuICAgIGVudHJ5LnF1ZXVlVGltZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBoZWFwIGFuZCBmaXggdGhlIGhlYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7TnVtYmVyfSAtIFRpbWUgb2YgZmlyc3QgZW50cnkgaW4gdGhlIGhlYXAuXG4gICAqL1xuICByZW1vdmUoZW50cnkpIHtcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZW50cnlcbiAgICBjb25zdCBpbmRleCA9IGluZGV4T2YodGhpcy5faGVhcCwgZW50cnkpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgbGFzdEluZGV4ID0gdGhpcy5fY3VycmVudExlbmd0aCAtIDE7XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRyeSBpcyB0aGUgbGFzdCBvbmVcbiAgICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIGhlYXBcbiAgICAgICAgdGhpcy5faGVhcFtsYXN0SW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB1cGRhdGUgY3VycmVudCBsZW5ndGhcbiAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcblxuICAgICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3dhcCB3aXRoIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGhlYXBcbiAgICAgICAgc3dhcCh0aGlzLl9oZWFwLCBpbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5fYnViYmxlRG93bigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBidWJibGUgdGhlIChleCBsYXN0KSBlbGVtZW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIGl0cyBuZXcgY29udGV4dFxuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5faGVhcFtpbmRleF07XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5faGVhcFtNYXRoLmZsb29yKGluZGV4IC8gMildO1xuXG4gICAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKVxuICAgICAgICAgICAgdGhpcy5fYnViYmxlVXAoaW5kZXgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZURvd24oaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IGxlbmd0aFxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBxdWV1ZS5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSAxO1xuICAgIHRoaXMuX2hlYXAgPSBuZXcgQXJyYXkodGhpcy5faGVhcC5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWYgdGhlIHF1ZXVlIGNvbnRhaW5zIHRoZSBnaXZlbiBgZW50cnlgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBFbnRyeSB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXMoZW50cnkpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhcC5pbmRleE9mKGVudHJ5KSAhPT0gLTE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcbiJdfQ==