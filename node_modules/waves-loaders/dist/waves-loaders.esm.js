function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

/**
 * Promise based implementation of XMLHttpRequest Level 2 for GET method.
 */
var Loader =
/*#__PURE__*/
function () {
  /**
   * @constructs
   * @param {string} [responseType=""] - responseType's value, "text" (equal to ""), "arraybuffer", "blob", "document" or "json"
   */
  function Loader() {
    var responseType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

    _classCallCheck(this, Loader);

    /**
     * @type {string}
     * @private
     */
    this.responseType = responseType;
    /**
     * @type {function}
     * @private
     */

    this.progressCb = undefined;
  }
  /**
   * Method for a promise based file loading.
   * Internally switch between loadOne and loadAll.
   * @public
   * @param {(string|string[])} fileURLs - The URL(s) of the files to load. Accepts a URL pointing to the file location or an array of URLs.
   * @returns {Promise}
   */


  _createClass(Loader, [{
    key: "load",
    value: function load(fileURLs) {
      if (fileURLs === undefined) throw new Error('Invalid fileURLs parameter: load method needs at least a url to load');
      if (Array.isArray(fileURLs)) return this.loadAll(fileURLs);else return this.loadOne(fileURLs);
    }
    /**
     * Load a single file
     * @private
     * @param {string} fileURL - The URL of the file to load.
     * @returns {Promise}
     */

  }, {
    key: "loadOne",
    value: function loadOne(fileURL) {
      return this.fileLoadingRequest(fileURL);
    }
    /**
     * Load all files at once in a single array and return a Promise
     * @private
     * @param {string[]} fileURLs - The URLs array of the files to load.
     * @returns {Promise}
     */

  }, {
    key: "loadAll",
    value: function loadAll(fileURLs) {
      var _this = this;

      var promises = fileURLs.map(function (fileURL, index) {
        return _this.fileLoadingRequest(fileURL, index);
      });
      return Promise.all(promises);
    }
    /**
     * Load a file asynchronously, return a Promise.
     * @private
     * @param {string} url - The URL of the file to load
     * @param {string} [index] - The index of the file in the array of files to load
     * @returns {Promise}
     */

  }, {
    key: "fileLoadingRequest",
    value: function fileLoadingRequest(url, index) {
      var _this2 = this;

      var promise = new Promise(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.index = index;

        if (_this2.responseType) {
          request.responseType = _this2.responseType;
        } else {
          var suffix = '.json';

          if (url.indexOf(suffix, _this2.length - suffix.length) !== -1) {
            request.responseType = 'json';
          } else {
            request.responseType = 'arraybuffer';
          }
        }

        request.addEventListener('load', function () {
          // Test request.status value, as 404 will also get there
          // Test request.status === 0 for cordova internal ajax calls
          if (request.readyState === 4 && (request.status === 200 || request.status === 304 || request.status === 0)) {
            // Hack for iOS 7, to remove as soon as possible
            if (this.responseType === 'json' && typeof request.response === 'string') request.response = JSON.parse(request.response);
            resolve(request.response);
          } else {
            reject(new Error(request.statusText));
          }
        });
        request.addEventListener('progress', function (evt) {
          if (_this2.progressCallback) {
            var event = {
              value: evt.loaded / evt.total,
              loaded: evt.loaded,
              total: evt.total
            };
            if (index !== undefined) event.index = index;

            _this2.progressCallback(event);
          }
        });
        request.addEventListener('abort', function (evt) {
          reject(new Error('Request Aborted'));
        });
        request.addEventListener('timeout', function (evt) {
          reject(new Error('Request Timeout'));
        }); // Manage network errors

        request.addEventListener('error', function () {
          reject(new Error('Network Error'));
        });
        request.send();
      });
      return promise;
    }
    /**
     * Alternative API to set the progress callback.
     * @type {function} callback - The callback that handles the response.
     */

  }, {
    key: "onProgress",
    value: function onProgress(callback) {
      this.progressCb = callback;
    }
    /**
     * Get the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function}
     */

  }, {
    key: "progressCallback",
    get: function get() {
      return this.progressCb;
    }
    /**
     * Set the callback function to get the progress of file loading process.
     * This is only for the file loading progress as decodeAudioData doesn't
     * expose a decode progress value.
     * @type {function} callback - The callback that handles the response.
     */
    ,
    set: function set(callback) {
      this.progressCb = callback;
    }
  }]);

  return Loader;
}();

var AudioContext = window.AudioContext || window.webkitAudioContext;
if (!AudioContext) throw new Error('WebAudio API not supported');
var audioContext = new AudioContext();
var silentBuffer = new Uint32Array([0x46464952, 0x00000038, 0x45564157, 0x20746d66, 0x00000010, 0x00010001, 0x0000ac44, 0x00015888, 0x00100002, 0x61746164, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]).buffer;

var noop = function noop() {}; // from spec `An AudioBuffer may be used by one or more AudioContexts`
// so no need to implement usage of an external AudioBuffer


var _decodeAudioData = audioContext.decodeAudioData;
var promise = audioContext.decodeAudioData(silentBuffer, noop, noop); // implement non promised base decode audio data

if (!promise) {
  _decodeAudioData = function decodeAudioData(arraybuffer) {
    return new Promise(function (resolve, reject) {
      audioContext.decodeAudioData(arraybuffer, function (buffer) {
        resolve(buffer);
      }, function (err) {
        throw new Error('Unable to decode audio data');
      });
    });
  };
}
/**
 * AudioBufferLoader
 * Promise based implementation of XMLHttpRequest Level 2 for GET method and
 * decode audio data for arraybuffer.
 */


var AudioBufferLoader =
/*#__PURE__*/
function (_Loader) {
  _inherits(AudioBufferLoader, _Loader);

  /**
   * Set the responseType to 'arraybuffer' and initialize options.
   * @param {string} [responseType="arraybuffer"]
   */
  function AudioBufferLoader() {
    var _this;

    var responseType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'arraybuffer';

    _classCallCheck(this, AudioBufferLoader);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioBufferLoader).call(this, responseType));
    _this.options = {
      wrapAroundExtension: 0
    };
    _this.responseType = responseType;
    _this.audioContext = audioContext;
    _this.decodeAudioData = _this.decodeAudioData.bind(_assertThisInitialized(_this));
    return _this;
  }
  /**
   * Allow to set the audio context that should be used in order to decode
   * the file and create the AudioBuffer.
   * @param {AudioContext} audioContext
   */


  _createClass(AudioBufferLoader, [{
    key: "setAudioContext",
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
    /**
     * Method for promise audio file loading and decoding.
     * @param {(string|string[])} fileURLs - The URL(s) of the audio files to load.
     *  Accepts a URL pointing to the file location or an array of URLs.
     * @param {{wrapAroundExtension: number}} [options] - Object with a
     *  wrapAroundExtension key which set the length, in seconds to be copied from
     *  the begining at the end of the returned AudioBuffer
     * @returns {Promise}
     */

  }, {
    key: "load",
    value: function load(fileURLs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.options = options;
      this.options.wrapAroundExtension = this.options.wrapAroundExtension || 0;
      return _get(_getPrototypeOf(AudioBufferLoader.prototype), "load", this).call(this, fileURLs);
    }
    /**
     * Load a single audio file, decode it in an AudioBuffer, return a Promise
     * @private
     * @param {string} fileURL - The URL of the audio file location to load.
     * @returns {Promise}
     */

  }, {
    key: "loadOne",
    value: function loadOne(fileURL) {
      return _get(_getPrototypeOf(AudioBufferLoader.prototype), "loadOne", this).call(this, fileURL).then(this.decodeAudioData)["catch"](function (err) {
        throw err;
      });
    }
    /**
     * Load all audio files at once in a single array, decode them in an array of
     * AudioBuffers, and return a Promise.
     * @private
     * @param {string[]} fileURLs - The URLs array of the audio files to load.
     * @returns {Promise}
     */

  }, {
    key: "loadAll",
    value: function loadAll(fileURLs) {
      var _this2 = this;

      return _get(_getPrototypeOf(AudioBufferLoader.prototype), "loadAll", this).call(this, fileURLs).then(function (arraybuffers) {
        var promises = arraybuffers.map(function (arraybuffer) {
          return _this2.decodeAudioData(arraybuffer);
        });
        return Promise.all(promises);
      })["catch"](function (err) {
        throw err;
      });
    }
    /**
     * Decode Audio Data, return a Promise
     * @private
     * @param {arraybuffer} - The arraybuffer of the loaded audio file to be decoded.
     * @returns {Promise}
     */

  }, {
    key: "decodeAudioData",
    value: function decodeAudioData(arraybuffer) {
      var _this3 = this;

      if (arraybuffer instanceof ArrayBuffer) {
        var _promise = _decodeAudioData.call(audioContext, arraybuffer);

        _promise.then(function (buffer) {
          if (_this3.options.wrapAroundExtension !== 0) buffer = _this3.__wrapAround(buffer);
          return Promise.resolve(buffer);
        })["catch"](function (err) {
          throw err;
        });

        return _promise;
      } else {
        return Promise.resolve(arraybuffer);
      }
    }
    /**
     * WrapAround, copy the begining input buffer to the end of an output buffer
     * @private
     * @param {arraybuffer} inBuffer {arraybuffer} - The input buffer
     * @returns {arraybuffer} - The processed buffer (with frame copied from the begining to the end)
     */

  }, {
    key: "__wrapAround",
    value: function __wrapAround(inBuffer) {
      var numberOfChannels = inBuffer.numberOfChannels,
          sampleRate = inBuffer.sampleRate,
          length = inBuffer.length;
      var outLength = length + this.options.wrapAroundExtension * sampleRate;
      var outBuffer = this.audioContext.createBuffer(numberOfChannels, outLength, sampleRate);

      for (var channel = 0; channel < numberOfChannels; channel++) {
        var channelData = inBuffer.getChannelData(channel);
        var outData = outBuffer.getChannelData(channel);
        var inLength = inBuffer.length;

        for (var i = 0; i < outLength; i++) {
          if (i < inLength) outData[i] = channelData[i];else outData[i] = channelData[i - inLength];
        }
      }

      return outBuffer;
    }
  }]);

  return AudioBufferLoader;
}(Loader);

/**
 * SuperLoader
 * Helper to load multiple type of files, and get them in their useful type, json for json files, AudioBuffer for audio files.
 */

var SuperLoader =
/*#__PURE__*/
function (_AudioBufferLoader) {
  _inherits(SuperLoader, _AudioBufferLoader);

  /**
   * Use composition to setup appropriate file loaders
   */
  function SuperLoader() {
    _classCallCheck(this, SuperLoader);

    return _possibleConstructorReturn(this, _getPrototypeOf(SuperLoader).call(this, null)); // bypass AudioBufferLoader constructor. This is bad but it works.
  }

  return SuperLoader;
}(AudioBufferLoader);

/**
 * @file Loaders: AudioBuffer loader and utilities
 * @author Samuel Goldszmidt
 * @version 0.1.1
 */

export { AudioBufferLoader, Loader, SuperLoader };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2F2ZXMtbG9hZGVycy5lc20uanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9sb2FkZXIuanMiLCIuLi9zcmMvYXVkaW8tYnVmZmVyLWxvYWRlci5qcyIsIi4uL3NyYy9zdXBlci1sb2FkZXIuanMiLCIuLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9taXNlIGJhc2VkIGltcGxlbWVudGF0aW9uIG9mIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZm9yIEdFVCBtZXRob2QuXG4gKi9cbmNsYXNzIExvYWRlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlVHlwZT1cIlwiXSAtIHJlc3BvbnNlVHlwZSdzIHZhbHVlLCBcInRleHRcIiAoZXF1YWwgdG8gXCJcIiksIFwiYXJyYXlidWZmZXJcIiwgXCJibG9iXCIsIFwiZG9jdW1lbnRcIiBvciBcImpzb25cIlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2VUeXBlID0gdW5kZWZpbmVkKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmVzc0NiID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgYSBwcm9taXNlIGJhc2VkIGZpbGUgbG9hZGluZy5cbiAgICogSW50ZXJuYWxseSBzd2l0Y2ggYmV0d2VlbiBsb2FkT25lIGFuZCBsb2FkQWxsLlxuICAgKiBAcHVibGljXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGZpbGVVUkxzIC0gVGhlIFVSTChzKSBvZiB0aGUgZmlsZXMgdG8gbG9hZC4gQWNjZXB0cyBhIFVSTCBwb2ludGluZyB0byB0aGUgZmlsZSBsb2NhdGlvbiBvciBhbiBhcnJheSBvZiBVUkxzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWQoZmlsZVVSTHMpIHtcbiAgICBpZiAoZmlsZVVSTHMgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgZmlsZVVSTHMgcGFyYW1ldGVyOiBsb2FkIG1ldGhvZCBuZWVkcyBhdCBsZWFzdCBhIHVybCB0byBsb2FkJykpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZVVSTHMpKVxuICAgICAgcmV0dXJuIHRoaXMubG9hZEFsbChmaWxlVVJMcyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMubG9hZE9uZShmaWxlVVJMcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIHNpbmdsZSBmaWxlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlVVJMIC0gVGhlIFVSTCBvZiB0aGUgZmlsZSB0byBsb2FkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRPbmUoZmlsZVVSTCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVMb2FkaW5nUmVxdWVzdChmaWxlVVJMKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBmaWxlcyBhdCBvbmNlIGluIGEgc2luZ2xlIGFycmF5IGFuZCByZXR1cm4gYSBQcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVVUkxzIC0gVGhlIFVSTHMgYXJyYXkgb2YgdGhlIGZpbGVzIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZEFsbChmaWxlVVJMcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gZmlsZVVSTHMubWFwKChmaWxlVVJMLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZUxvYWRpbmdSZXF1ZXN0KGZpbGVVUkwsIGluZGV4KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIGZpbGUgYXN5bmNocm9ub3VzbHksIHJldHVybiBhIFByb21pc2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmaWxlIHRvIGxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpbmRleF0gLSBUaGUgaW5kZXggb2YgdGhlIGZpbGUgaW4gdGhlIGFycmF5IG9mIGZpbGVzIHRvIGxvYWRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBmaWxlTG9hZGluZ1JlcXVlc3QodXJsLCBpbmRleCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXF1ZXN0LmluZGV4ID0gaW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gJy5qc29uJztcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKHN1ZmZpeCwgdGhpcy5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRlc3QgcmVxdWVzdC5zdGF0dXMgdmFsdWUsIGFzIDQwNCB3aWxsIGFsc28gZ2V0IHRoZXJlXG4gICAgICAgIC8vIFRlc3QgcmVxdWVzdC5zdGF0dXMgPT09IDAgZm9yIGNvcmRvdmEgaW50ZXJuYWwgYWpheCBjYWxsc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQgJiZcbiAgICAgICAgICAgIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAzMDQgfHzCoHJlcXVlc3Quc3RhdHVzID09PSAwKVxuICAgICAgICAgICkge1xuICAgICAgICAgIC8vIEhhY2sgZm9yIGlPUyA3LCB0byByZW1vdmUgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIHR5cGVvZihyZXF1ZXN0LnJlc3BvbnNlKSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlKTtcblxuICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZXZ0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBldnQubG9hZGVkIC8gZXZ0LnRvdGFsLFxuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGV2ZW50LmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGV2dCA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgQWJvcnRlZCcpKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCBldnQgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdSZXF1ZXN0IFRpbWVvdXQnKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTWFuYWdlIG5ldHdvcmsgZXJyb3JzXG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05ldHdvcmsgRXJyb3InKSk7XG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZSBBUEkgdG8gc2V0IHRoZSBwcm9ncmVzcyBjYWxsYmFjay5cbiAgICogQHR5cGUge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgdGhlIHJlc3BvbnNlLlxuICAgKi9cbiAgb25Qcm9ncmVzcyhjYWxsYmFjaykge1xuICAgIHRoaXMucHJvZ3Jlc3NDYiA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZ2V0IHRoZSBwcm9ncmVzcyBvZiBmaWxlIGxvYWRpbmcgcHJvY2Vzcy5cbiAgICogVGhpcyBpcyBvbmx5IGZvciB0aGUgZmlsZSBsb2FkaW5nIHByb2dyZXNzIGFzIGRlY29kZUF1ZGlvRGF0YSBkb2Vzbid0XG4gICAqIGV4cG9zZSBhIGRlY29kZSBwcm9ncmVzcyB2YWx1ZS5cbiAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHByb2dyZXNzQ2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NDYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgcHJvZ3Jlc3Mgb2YgZmlsZSBsb2FkaW5nIHByb2Nlc3MuXG4gICAqIFRoaXMgaXMgb25seSBmb3IgdGhlIGZpbGUgbG9hZGluZyBwcm9ncmVzcyBhcyBkZWNvZGVBdWRpb0RhdGEgZG9lc24ndFxuICAgKiBleHBvc2UgYSBkZWNvZGUgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqIEB0eXBlIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIHRoZSByZXNwb25zZS5cbiAgICovXG4gIHNldCBwcm9ncmVzc0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcm9ncmVzc0NiID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyO1xuIiwiaW1wb3J0IExvYWRlciBmcm9tICcuL2xvYWRlcic7XG5cbmNvbnN0IEF1ZGlvQ29udGV4dCA9ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuXG5pZiAoIUF1ZGlvQ29udGV4dClcbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBdWRpbyBBUEkgbm90IHN1cHBvcnRlZCcpO1xuXG5jb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG5cbmNvbnN0IHNpbGVudEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4NDY0NjQ5NTIsIDB4MDAwMDAwMzgsIDB4NDU1NjQxNTcsIDB4MjA3NDZkNjYsXG4gIDB4MDAwMDAwMTAsIDB4MDAwMTAwMDEsIDB4MDAwMGFjNDQsIDB4MDAwMTU4ODgsXG4gIDB4MDAxMDAwMDIsIDB4NjE3NDYxNjQsIDB4MDAwMDAwMTQsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG4gIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsIDB4MDAwMDAwMDAsXG5dKS5idWZmZXI7XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gZnJvbSBzcGVjIGBBbiBBdWRpb0J1ZmZlciBtYXkgYmUgdXNlZCBieSBvbmUgb3IgbW9yZSBBdWRpb0NvbnRleHRzYFxuLy8gc28gbm8gbmVlZCB0byBpbXBsZW1lbnQgdXNhZ2Ugb2YgYW4gZXh0ZXJuYWwgQXVkaW9CdWZmZXJcbmxldCBkZWNvZGVBdWRpb0RhdGEgPSBhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhO1xuY29uc3QgcHJvbWlzZSA9IGF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoc2lsZW50QnVmZmVyLCBub29wLCBub29wKTtcbi8vIGltcGxlbWVudCBub24gcHJvbWlzZWQgYmFzZSBkZWNvZGUgYXVkaW8gZGF0YVxuaWYgKCFwcm9taXNlKSB7XG4gIGRlY29kZUF1ZGlvRGF0YSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlciwgKGJ1ZmZlcikgPT4ge1xuICAgICAgICByZXNvbHZlKGJ1ZmZlcik7XG4gICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY29kZSBhdWRpbyBkYXRhJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbi8qKlxuICogQXVkaW9CdWZmZXJMb2FkZXJcbiAqIFByb21pc2UgYmFzZWQgaW1wbGVtZW50YXRpb24gb2YgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMiBmb3IgR0VUIG1ldGhvZCBhbmRcbiAqIGRlY29kZSBhdWRpbyBkYXRhIGZvciBhcnJheWJ1ZmZlci5cbiAqL1xuY2xhc3MgQXVkaW9CdWZmZXJMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICAvKipcbiAgICogU2V0IHRoZSByZXNwb25zZVR5cGUgdG8gJ2FycmF5YnVmZmVyJyBhbmQgaW5pdGlhbGl6ZSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Jlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCJdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInKSB7XG4gICAgc3VwZXIocmVzcG9uc2VUeXBlKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHsgd3JhcEFyb3VuZEV4dGVuc2lvbjogMCB9O1xuICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuXG4gICAgdGhpcy5kZWNvZGVBdWRpb0RhdGEgPSB0aGlzLmRlY29kZUF1ZGlvRGF0YS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IHRvIHNldCB0aGUgYXVkaW8gY29udGV4dCB0aGF0IHNob3VsZCBiZSB1c2VkIGluIG9yZGVyIHRvIGRlY29kZVxuICAgKiB0aGUgZmlsZSBhbmQgY3JlYXRlIHRoZSBBdWRpb0J1ZmZlci5cbiAgICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgcHJvbWlzZSBhdWRpbyBmaWxlIGxvYWRpbmcgYW5kIGRlY29kaW5nLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBmaWxlVVJMcyAtIFRoZSBVUkwocykgb2YgdGhlIGF1ZGlvIGZpbGVzIHRvIGxvYWQuXG4gICAqICBBY2NlcHRzIGEgVVJMIHBvaW50aW5nIHRvIHRoZSBmaWxlIGxvY2F0aW9uIG9yIGFuIGFycmF5IG9mIFVSTHMuXG4gICAqIEBwYXJhbSB7e3dyYXBBcm91bmRFeHRlbnNpb246IG51bWJlcn19IFtvcHRpb25zXSAtIE9iamVjdCB3aXRoIGFcbiAgICogIHdyYXBBcm91bmRFeHRlbnNpb24ga2V5IHdoaWNoIHNldCB0aGUgbGVuZ3RoLCBpbiBzZWNvbmRzIHRvIGJlIGNvcGllZCBmcm9tXG4gICAqICB0aGUgYmVnaW5pbmcgYXQgdGhlIGVuZCBvZiB0aGUgcmV0dXJuZWQgQXVkaW9CdWZmZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkKGZpbGVVUkxzLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24gfHwgMDtcblxuICAgIHJldHVybiBzdXBlci5sb2FkKGZpbGVVUkxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgc2luZ2xlIGF1ZGlvIGZpbGUsIGRlY29kZSBpdCBpbiBhbiBBdWRpb0J1ZmZlciwgcmV0dXJuIGEgUHJvbWlzZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVVSTCAtIFRoZSBVUkwgb2YgdGhlIGF1ZGlvIGZpbGUgbG9jYXRpb24gdG8gbG9hZC5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2FkT25lKGZpbGVVUkwpIHtcbiAgICByZXR1cm4gc3VwZXIubG9hZE9uZShmaWxlVVJMKVxuICAgICAgLnRoZW4odGhpcy5kZWNvZGVBdWRpb0RhdGEpXG4gICAgICAuY2F0Y2goKGVycikgPT4geyB0aHJvdyBlcnI7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIGF1ZGlvIGZpbGVzIGF0IG9uY2UgaW4gYSBzaW5nbGUgYXJyYXksIGRlY29kZSB0aGVtIGluIGFuIGFycmF5IG9mXG4gICAqIEF1ZGlvQnVmZmVycywgYW5kIHJldHVybiBhIFByb21pc2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVVUkxzIC0gVGhlIFVSTHMgYXJyYXkgb2YgdGhlIGF1ZGlvIGZpbGVzIHRvIGxvYWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbG9hZEFsbChmaWxlVVJMcykge1xuICAgIHJldHVybiBzdXBlci5sb2FkQWxsKGZpbGVVUkxzKVxuICAgICAgLnRoZW4oKGFycmF5YnVmZmVycykgPT4ge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGFycmF5YnVmZmVycy5tYXAoKGFycmF5YnVmZmVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4geyB0aHJvdyBlcnI7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBBdWRpbyBEYXRhLCByZXR1cm4gYSBQcm9taXNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YXJyYXlidWZmZXJ9IC0gVGhlIGFycmF5YnVmZmVyIG9mIHRoZSBsb2FkZWQgYXVkaW8gZmlsZSB0byBiZSBkZWNvZGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlcikge1xuICAgIGlmIChhcnJheWJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gZGVjb2RlQXVkaW9EYXRhLmNhbGwoYXVkaW9Db250ZXh0LCBhcnJheWJ1ZmZlcilcblxuICAgICAgcHJvbWlzZVxuICAgICAgICAudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uICE9PSAwKVxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5fX3dyYXBBcm91bmQoYnVmZmVyKTtcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnVmZmVyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHsgdGhyb3cgZXJyOyB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYXJyYXlidWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwQXJvdW5kLCBjb3B5IHRoZSBiZWdpbmluZyBpbnB1dCBidWZmZXIgdG8gdGhlIGVuZCBvZiBhbiBvdXRwdXQgYnVmZmVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7YXJyYXlidWZmZXJ9IGluQnVmZmVyIHthcnJheWJ1ZmZlcn0gLSBUaGUgaW5wdXQgYnVmZmVyXG4gICAqIEByZXR1cm5zIHthcnJheWJ1ZmZlcn0gLSBUaGUgcHJvY2Vzc2VkIGJ1ZmZlciAod2l0aCBmcmFtZSBjb3BpZWQgZnJvbSB0aGUgYmVnaW5pbmcgdG8gdGhlIGVuZClcbiAgICovXG4gIF9fd3JhcEFyb3VuZChpbkJ1ZmZlcikge1xuICAgIGNvbnN0IHsgbnVtYmVyT2ZDaGFubmVscywgc2FtcGxlUmF0ZSwgbGVuZ3RoIH0gPSBpbkJ1ZmZlcjtcbiAgICBjb25zdCBvdXRMZW5ndGggPSBsZW5ndGggKyB0aGlzLm9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiAqIHNhbXBsZVJhdGU7XG4gICAgY29uc3Qgb3V0QnVmZmVyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKG51bWJlck9mQ2hhbm5lbHMsIG91dExlbmd0aCwgc2FtcGxlUmF0ZSk7XG5cbiAgICBmb3IgKGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG51bWJlck9mQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuICAgICAgY29uc3QgY2hhbm5lbERhdGEgPSBpbkJ1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsKTtcbiAgICAgIGNvbnN0IG91dERhdGEgPSBvdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG4gICAgICBjb25zdCBpbkxlbmd0aCA9IGluQnVmZmVyLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGluTGVuZ3RoKVxuICAgICAgICAgIG91dERhdGFbaV0gPSBjaGFubmVsRGF0YVtpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dERhdGFbaV0gPSBjaGFubmVsRGF0YVtpIC0gaW5MZW5ndGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRCdWZmZXI7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXVkaW9CdWZmZXJMb2FkZXI7XG4iLCJpbXBvcnQgQXVkaW9CdWZmZXJMb2FkZXIgZnJvbSAnLi9hdWRpby1idWZmZXItbG9hZGVyJztcblxuXG4vKipcbiAqIFN1cGVyTG9hZGVyXG4gKiBIZWxwZXIgdG8gbG9hZCBtdWx0aXBsZSB0eXBlIG9mIGZpbGVzLCBhbmQgZ2V0IHRoZW0gaW4gdGhlaXIgdXNlZnVsIHR5cGUsIGpzb24gZm9yIGpzb24gZmlsZXMsIEF1ZGlvQnVmZmVyIGZvciBhdWRpbyBmaWxlcy5cbiAqL1xuY2xhc3MgU3VwZXJMb2FkZXIgZXh0ZW5kcyBBdWRpb0J1ZmZlckxvYWRlciB7XG4gIC8qKlxuICAgKiBVc2UgY29tcG9zaXRpb24gdG8gc2V0dXAgYXBwcm9wcmlhdGUgZmlsZSBsb2FkZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihudWxsKTtcbiAgICAvLyBieXBhc3MgQXVkaW9CdWZmZXJMb2FkZXIgY29uc3RydWN0b3IuIFRoaXMgaXMgYmFkIGJ1dCBpdCB3b3Jrcy5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdXBlckxvYWRlcjtcbiIsIi8qKlxuICogQGZpbGUgTG9hZGVyczogQXVkaW9CdWZmZXIgbG9hZGVyIGFuZCB1dGlsaXRpZXNcbiAqIEBhdXRob3IgU2FtdWVsIEdvbGRzem1pZHRcbiAqIEB2ZXJzaW9uIDAuMS4xXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb0J1ZmZlckxvYWRlciB9IGZyb20gJy4vYXVkaW8tYnVmZmVyLWxvYWRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1cGVyTG9hZGVyIH0gZnJvbSAnLi9zdXBlci1sb2FkZXInO1xuIl0sIm5hbWVzIjpbIkxvYWRlciIsInJlc3BvbnNlVHlwZSIsInVuZGVmaW5lZCIsInByb2dyZXNzQ2IiLCJmaWxlVVJMcyIsIkVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwibG9hZEFsbCIsImxvYWRPbmUiLCJmaWxlVVJMIiwiZmlsZUxvYWRpbmdSZXF1ZXN0IiwicHJvbWlzZXMiLCJtYXAiLCJpbmRleCIsIlByb21pc2UiLCJhbGwiLCJ1cmwiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzdWZmaXgiLCJpbmRleE9mIiwibGVuZ3RoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsIkpTT04iLCJwYXJzZSIsInN0YXR1c1RleHQiLCJldnQiLCJwcm9ncmVzc0NhbGxiYWNrIiwiZXZlbnQiLCJ2YWx1ZSIsImxvYWRlZCIsInRvdGFsIiwic2VuZCIsImNhbGxiYWNrIiwiQXVkaW9Db250ZXh0Iiwid2luZG93Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiYXVkaW9Db250ZXh0Iiwic2lsZW50QnVmZmVyIiwiVWludDMyQXJyYXkiLCJidWZmZXIiLCJub29wIiwiZGVjb2RlQXVkaW9EYXRhIiwiYXJyYXlidWZmZXIiLCJlcnIiLCJBdWRpb0J1ZmZlckxvYWRlciIsIm9wdGlvbnMiLCJ3cmFwQXJvdW5kRXh0ZW5zaW9uIiwiYmluZCIsInRoZW4iLCJhcnJheWJ1ZmZlcnMiLCJBcnJheUJ1ZmZlciIsImNhbGwiLCJfX3dyYXBBcm91bmQiLCJpbkJ1ZmZlciIsIm51bWJlck9mQ2hhbm5lbHMiLCJzYW1wbGVSYXRlIiwib3V0TGVuZ3RoIiwib3V0QnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiY2hhbm5lbCIsImNoYW5uZWxEYXRhIiwiZ2V0Q2hhbm5lbERhdGEiLCJvdXREYXRhIiwiaW5MZW5ndGgiLCJpIiwiU3VwZXJMb2FkZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7SUFHTUE7Ozs7Ozs7b0JBS2tDO1FBQTFCQyxZQUEwQix1RUFBWEMsU0FBVzs7Ozs7Ozs7U0FLL0JELFlBQUwsR0FBb0JBLFlBQXBCOzs7Ozs7U0FNS0UsVUFBTCxHQUFrQkQsU0FBbEI7Ozs7Ozs7Ozs7Ozs7eUJBVUdFLFVBQVU7VUFDVEEsUUFBUSxLQUFLRixTQUFqQixFQUNFLE1BQU8sSUFBSUcsS0FBSixDQUFVLHNFQUFWLENBQVA7VUFFRUMsS0FBSyxDQUFDQyxPQUFOLENBQWNILFFBQWQsQ0FBSixFQUNFLE9BQU8sS0FBS0ksT0FBTCxDQUFhSixRQUFiLENBQVAsQ0FERixLQUdFLE9BQU8sS0FBS0ssT0FBTCxDQUFhTCxRQUFiLENBQVA7Ozs7Ozs7Ozs7OzRCQVNJTSxTQUFTO2FBQ1IsS0FBS0Msa0JBQUwsQ0FBd0JELE9BQXhCLENBQVA7Ozs7Ozs7Ozs7OzRCQVNNTixVQUFVOzs7VUFD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
