'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _AudioTimeEngine2 = require('../core/AudioTimeEngine');

var _AudioTimeEngine3 = _interopRequireDefault(_AudioTimeEngine2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or lessÂ periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine/index.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // segment period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * segmentPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_AudioTimeEngine3.default);

exports.default = SegmentEngine;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNlZ21lbnRFbmdpbmUuanMiXSwibmFtZXMiOlsib3B0T3JEZWYiLCJvcHQiLCJkZWYiLCJ1bmRlZmluZWQiLCJnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4Iiwic29ydGVkQXJyYXkiLCJ2YWx1ZSIsImluZGV4Iiwic2l6ZSIsImxlbmd0aCIsImZpcnN0VmFsIiwibGFzdFZhbCIsIk1hdGgiLCJmbG9vciIsImdldEN1cnJlbnRPck5leHRJbmRleCIsIlNlZ21lbnRFbmdpbmUiLCJvcHRpb25zIiwiYXVkaW9Db250ZXh0IiwiYnVmZmVyIiwicGVyaW9kQWJzIiwicGVyaW9kUmVsIiwicGVyaW9kVmFyIiwicGVyaW9kTWluIiwicG9zaXRpb25BcnJheSIsInBvc2l0aW9uVmFyIiwiZHVyYXRpb25BcnJheSIsImR1cmF0aW9uQWJzIiwiZHVyYXRpb25SZWwiLCJvZmZzZXRBcnJheSIsIm9mZnNldEFicyIsIm9mZnNldFJlbCIsImRlbGF5IiwiYXR0YWNrQWJzIiwiYXR0YWNrUmVsIiwicmVsZWFzZUFicyIsInJlbGVhc2VSZWwiLCJyZXNhbXBsaW5nIiwicmVzYW1wbGluZ1ZhciIsImdhaW4iLCJzZWdtZW50SW5kZXgiLCJjeWNsaWMiLCJfX2N5Y2xpY09mZnNldCIsIm1vbm9waG9uaWMiLCJfX2N1cnJlbnRTcmMiLCJfX2N1cnJlbnRFbnYiLCJfX3JlbGVhc2VTdGFydFRpbWUiLCJfX2N1cnJlbnRHYWluIiwiX19jdXJyZW50RW5kVGltZSIsImFib3J0VGltZSIsIndyYXBBcm91bmRFeHRlbnNpb24iLCJvdXRwdXROb2RlIiwiY3JlYXRlR2FpbiIsInRpbWUiLCJtYXgiLCJjdXJyZW50VGltZSIsInRyaWdnZXIiLCJwb3NpdGlvbiIsInNwZWVkIiwiY3ljbGljT2Zmc2V0IiwiYnVmZmVyRHVyYXRpb24iLCJjeWNsZXMiLCJJbmZpbml0eSIsInNlZ21lbnRUaW1lIiwic2VnbWVudFBlcmlvZCIsInNlZ21lbnRQb3NpdGlvbiIsInNlZ21lbnREdXJhdGlvbiIsInNlZ21lbnRPZmZzZXQiLCJyZXNhbXBsaW5nUmF0ZSIsIm1pbiIsInJhbmRvbVJlc2FtcGxpbmciLCJyYW5kb20iLCJwb3ciLCJuZXh0U2VnbWVudEluZGV4IiwibmV4dFBvc2l0aW9uIiwibmV4dE9mZnNldCIsImludGVyU2VnbWVudERpc3RhbmNlIiwiZHVyYXRpb24iLCJhYm9ydCIsImVudmVsb3BlIiwiYXR0YWNrIiwicmVsZWFzZSIsImZhY3RvciIsImF0dGFja0VuZFRpbWUiLCJzZWdtZW50RW5kVGltZSIsInJlbGVhc2VTdGFydFRpbWUiLCJzZXRWYWx1ZUF0VGltZSIsImxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lIiwiY29ubmVjdCIsInNvdXJjZSIsImNyZWF0ZUJ1ZmZlclNvdXJjZSIsInBsYXliYWNrUmF0ZSIsInN0YXJ0Iiwic3RvcCIsImVuZFRpbWUiLCJjdXJyZW50R2FpblZhbHVlIiwicmVsZWFzZVN0YXJ0IiwiY2FuY2VsU2NoZWR1bGVkVmFsdWVzIiwiQXVkaW9UaW1lRW5naW5lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsTUFBSUQsUUFBUUUsU0FBWixFQUNFLE9BQU9GLEdBQVA7O0FBRUYsU0FBT0MsR0FBUDtBQUNEOztBQUVELFNBQVNFLHlCQUFULENBQW1DQyxXQUFuQyxFQUFnREMsS0FBaEQsRUFBbUU7QUFBQSxNQUFaQyxLQUFZLHVFQUFKLENBQUMsQ0FBRzs7QUFDakUsTUFBSUMsT0FBT0gsWUFBWUksTUFBdkI7O0FBRUEsTUFBSUQsT0FBTyxDQUFYLEVBQWM7QUFDWixRQUFJRSxXQUFXTCxZQUFZLENBQVosQ0FBZjtBQUNBLFFBQUlNLFVBQVVOLFlBQVlHLE9BQU8sQ0FBbkIsQ0FBZDs7QUFFQSxRQUFJRixRQUFRSSxRQUFaLEVBQ0VILFFBQVEsQ0FBQyxDQUFULENBREYsS0FFSyxJQUFJRCxTQUFTSyxPQUFiLEVBQ0hKLFFBQVFDLE9BQU8sQ0FBZixDQURHLEtBRUE7QUFDSCxVQUFJRCxRQUFRLENBQVIsSUFBYUEsU0FBU0MsSUFBMUIsRUFDRUQsUUFBUUssS0FBS0MsS0FBTCxDQUFXLENBQUNMLE9BQU8sQ0FBUixLQUFjRixRQUFRSSxRQUF0QixLQUFtQ0MsVUFBVUQsUUFBN0MsQ0FBWCxDQUFSOztBQUVGLGFBQU9MLFlBQVlFLEtBQVosSUFBcUJELEtBQTVCO0FBQ0VDO0FBREYsT0FHQSxPQUFPRixZQUFZRSxRQUFRLENBQXBCLEtBQTBCRCxLQUFqQztBQUNFQztBQURGO0FBRUQ7QUFDRjs7QUFFRCxTQUFPQSxLQUFQO0FBQ0Q7O0FBRUQsU0FBU08scUJBQVQsQ0FBK0JULFdBQS9CLEVBQTRDQyxLQUE1QyxFQUErRDtBQUFBLE1BQVpDLEtBQVksdUVBQUosQ0FBQyxDQUFHOztBQUM3RCxNQUFJQyxPQUFPSCxZQUFZSSxNQUF2Qjs7QUFFQSxNQUFJRCxPQUFPLENBQVgsRUFBYztBQUNaLFFBQUlFLFdBQVdMLFlBQVksQ0FBWixDQUFmO0FBQ0EsUUFBSU0sVUFBVU4sWUFBWUcsT0FBTyxDQUFuQixDQUFkOztBQUVBLFFBQUlGLFNBQVNJLFFBQWIsRUFDRUgsUUFBUSxDQUFSLENBREYsS0FFSyxJQUFJRCxTQUFTSyxPQUFiLEVBQ0hKLFFBQVFDLElBQVIsQ0FERyxLQUVBO0FBQ0gsVUFBSUQsUUFBUSxDQUFSLElBQWFBLFNBQVNDLElBQTFCLEVBQ0VELFFBQVFLLEtBQUtDLEtBQUwsQ0FBVyxDQUFDTCxPQUFPLENBQVIsS0FBY0YsUUFBUUksUUFBdEIsS0FBbUNDLFVBQVVELFFBQTdDLENBQVgsQ0FBUjs7QUFFRixhQUFPTCxZQUFZRSxLQUFaLElBQXFCRCxLQUE1QjtBQUNFQztBQURGLE9BR0EsT0FBT0YsWUFBWUUsUUFBUSxDQUFwQixLQUEwQkQsS0FBakM7QUFDRUM7QUFERjtBQUVEO0FBQ0Y7O0FBRUQsU0FBT0EsS0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxRE1RLGE7OztBQUNKLDJCQUEwQjtBQUFBLFFBQWRDLE9BQWMsdUVBQUosRUFBSTtBQUFBOztBQUd4Qjs7Ozs7Ozs7QUFId0Isb0pBQ2xCQSxRQUFRQyxZQURVOztBQVd4QixVQUFLQyxNQUFMLEdBQWNsQixTQUFTZ0IsUUFBUUUsTUFBakIsRUFBeUIsSUFBekIsQ0FBZDs7QUFFQTs7Ozs7Ozs7QUFRQSxVQUFLQyxTQUFMLEdBQWlCbkIsU0FBU2dCLFFBQVFHLFNBQWpCLEVBQTRCLENBQTVCLENBQWpCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLFNBQUwsR0FBaUJwQixTQUFTZ0IsUUFBUUksU0FBakIsRUFBNEIsQ0FBNUIsQ0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsU0FBTCxHQUFpQnJCLFNBQVNnQixRQUFRSyxTQUFqQixFQUE0QixDQUE1QixDQUFqQjs7QUFFQTs7Ozs7Ozs7QUFRQSxVQUFLQyxTQUFMLEdBQWlCdEIsU0FBU2dCLFFBQVFNLFNBQWpCLEVBQTRCLEtBQTVCLENBQWpCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLGFBQUwsR0FBcUJ2QixTQUFTZ0IsUUFBUU8sYUFBakIsRUFBZ0MsQ0FBQyxHQUFELENBQWhDLENBQXJCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLFdBQUwsR0FBbUJ4QixTQUFTZ0IsUUFBUVEsV0FBakIsRUFBOEIsQ0FBOUIsQ0FBbkI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsYUFBTCxHQUFxQnpCLFNBQVNnQixRQUFRUyxhQUFqQixFQUFnQyxDQUFDLEdBQUQsQ0FBaEMsQ0FBckI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsV0FBTCxHQUFtQjFCLFNBQVNnQixRQUFRVSxXQUFqQixFQUE4QixDQUE5QixDQUFuQjs7QUFFQTs7Ozs7Ozs7QUFRQSxVQUFLQyxXQUFMLEdBQW1CM0IsU0FBU2dCLFFBQVFXLFdBQWpCLEVBQThCLENBQTlCLENBQW5COztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUEsVUFBS0MsV0FBTCxHQUFtQjVCLFNBQVNnQixRQUFRWSxXQUFqQixFQUE4QixDQUFDLEdBQUQsQ0FBOUIsQ0FBbkI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsU0FBTCxHQUFpQjdCLFNBQVNnQixRQUFRYSxTQUFqQixFQUE0QixDQUFDLEtBQTdCLENBQWpCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLFNBQUwsR0FBaUI5QixTQUFTZ0IsUUFBUWMsU0FBakIsRUFBNEIsQ0FBNUIsQ0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsS0FBTCxHQUFhL0IsU0FBU2dCLFFBQVFlLEtBQWpCLEVBQXdCLEtBQXhCLENBQWI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsU0FBTCxHQUFpQmhDLFNBQVNnQixRQUFRZ0IsU0FBakIsRUFBNEIsS0FBNUIsQ0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsU0FBTCxHQUFpQmpDLFNBQVNnQixRQUFRaUIsU0FBakIsRUFBNEIsQ0FBNUIsQ0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsVUFBTCxHQUFrQmxDLFNBQVNnQixRQUFRa0IsVUFBakIsRUFBNkIsS0FBN0IsQ0FBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsVUFBTCxHQUFrQm5DLFNBQVNnQixRQUFRbUIsVUFBakIsRUFBNkIsQ0FBN0IsQ0FBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsVUFBTCxHQUFrQnBDLFNBQVNnQixRQUFRb0IsVUFBakIsRUFBNkIsQ0FBN0IsQ0FBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsYUFBTCxHQUFxQnJDLFNBQVNnQixRQUFRcUIsYUFBakIsRUFBZ0MsQ0FBaEMsQ0FBckI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsSUFBTCxHQUFZdEMsU0FBU2dCLFFBQVFzQixJQUFqQixFQUF1QixDQUF2QixDQUFaOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLFlBQUwsR0FBb0J2QyxTQUFTZ0IsUUFBUXVCLFlBQWpCLEVBQStCLENBQS9CLENBQXBCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLE1BQUwsR0FBY3hDLFNBQVNnQixRQUFRd0IsTUFBakIsRUFBeUIsS0FBekIsQ0FBZDtBQUNBLFVBQUtDLGNBQUwsR0FBc0IsQ0FBdEI7O0FBRUE7Ozs7Ozs7O0FBUUEsVUFBS0MsVUFBTCxHQUFrQjFDLFNBQVNnQixRQUFRMEIsVUFBakIsRUFBNkIsS0FBN0IsQ0FBbEI7QUFDQSxVQUFLQyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsVUFBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFVBQUtDLGtCQUFMLEdBQTBCLENBQTFCO0FBQ0EsVUFBS0MsYUFBTCxHQUFxQixDQUFyQjtBQUNBLFVBQUtDLGdCQUFMLEdBQXdCLENBQXhCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLFNBQUwsR0FBaUJoRCxTQUFTZ0IsUUFBUWdDLFNBQWpCLEVBQTRCLEtBQTVCLENBQWpCOztBQUVBOzs7Ozs7OztBQVFBLFVBQUtDLG1CQUFMLEdBQTJCakQsU0FBU2dCLFFBQVFpQyxtQkFBakIsRUFBc0MsQ0FBdEMsQ0FBM0I7O0FBRUEsVUFBS0MsVUFBTCxHQUFrQixNQUFLakMsWUFBTCxDQUFrQmtDLFVBQWxCLEVBQWxCO0FBbFJ3QjtBQW1SekI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO2dDQUNZQyxJLEVBQU07QUFDaEJBLGFBQU94QyxLQUFLeUMsR0FBTCxDQUFTRCxJQUFULEVBQWUsS0FBS25DLFlBQUwsQ0FBa0JxQyxXQUFqQyxDQUFQO0FBQ0EsYUFBT0YsT0FBTyxLQUFLRyxPQUFMLENBQWFILElBQWIsQ0FBZDtBQUNEOztBQUVEOzs7O2lDQUNhQSxJLEVBQU1JLFEsRUFBVUMsSyxFQUFPO0FBQ2xDLFVBQUlsRCxRQUFRLEtBQUtnQyxZQUFqQjtBQUNBLFVBQUltQixlQUFlLENBQW5CO0FBQ0EsVUFBSUMsaUJBQWlCLEtBQUtBLGNBQTFCOztBQUVBLFVBQUksS0FBS25CLE1BQVQsRUFBaUI7QUFDZixZQUFJb0IsU0FBU0osV0FBV0csY0FBeEI7O0FBRUFELHVCQUFlOUMsS0FBS0MsS0FBTCxDQUFXK0MsTUFBWCxJQUFxQkQsY0FBcEM7QUFDQUgsb0JBQVlFLFlBQVo7QUFDRDs7QUFFRCxVQUFJRCxRQUFRLENBQVosRUFBZTtBQUNibEQsZ0JBQVFPLHNCQUFzQixLQUFLUyxhQUEzQixFQUEwQ2lDLFFBQTFDLENBQVI7O0FBRUEsWUFBSWpELFNBQVMsS0FBS2dCLGFBQUwsQ0FBbUJkLE1BQWhDLEVBQXdDO0FBQ3RDRixrQkFBUSxDQUFSO0FBQ0FtRCwwQkFBZ0JDLGNBQWhCOztBQUVBLGNBQUksQ0FBQyxLQUFLbkIsTUFBVixFQUNFLE9BQU9xQixRQUFQO0FBQ0g7QUFDRixPQVZELE1BVU8sSUFBSUosUUFBUSxDQUFaLEVBQWU7QUFDcEJsRCxnQkFBUUgsMEJBQTBCLEtBQUttQixhQUEvQixFQUE4Q2lDLFFBQTlDLENBQVI7O0FBRUEsWUFBSWpELFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGtCQUFRLEtBQUtnQixhQUFMLENBQW1CZCxNQUFuQixHQUE0QixDQUFwQztBQUNBaUQsMEJBQWdCQyxjQUFoQjs7QUFFQSxjQUFJLENBQUMsS0FBS25CLE1BQVYsRUFDRSxPQUFPLENBQUNxQixRQUFSO0FBQ0g7QUFDRixPQVZNLE1BVUE7QUFDTCxlQUFPQSxRQUFQO0FBQ0Q7O0FBRUQsV0FBS3RCLFlBQUwsR0FBb0JoQyxLQUFwQjtBQUNBLFdBQUtrQyxjQUFMLEdBQXNCaUIsWUFBdEI7O0FBRUEsYUFBT0EsZUFBZSxLQUFLbkMsYUFBTCxDQUFtQmhCLEtBQW5CLENBQXRCO0FBQ0Q7O0FBRUQ7Ozs7b0NBQ2dCNkMsSSxFQUFNSSxRLEVBQVVDLEssRUFBTztBQUNyQyxVQUFJbEQsUUFBUSxLQUFLZ0MsWUFBakI7QUFDQSxVQUFJbUIsZUFBZSxLQUFLakIsY0FBeEI7O0FBRUEsV0FBS2MsT0FBTCxDQUFhSCxJQUFiOztBQUVBLFVBQUlLLFFBQVEsQ0FBWixFQUFlO0FBQ2JsRDs7QUFFQSxZQUFJQSxTQUFTLEtBQUtnQixhQUFMLENBQW1CZCxNQUFoQyxFQUF3QztBQUN0Q0Ysa0JBQVEsQ0FBUjtBQUNBbUQsMEJBQWdCLEtBQUtDLGNBQXJCOztBQUVBLGNBQUksQ0FBQyxLQUFLbkIsTUFBVixFQUNFLE9BQU9xQixRQUFQO0FBQ0g7QUFDRixPQVZELE1BVU87QUFDTHREOztBQUVBLFlBQUlBLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGtCQUFRLEtBQUtnQixhQUFMLENBQW1CZCxNQUFuQixHQUE0QixDQUFwQztBQUNBaUQsMEJBQWdCLEtBQUtDLGNBQXJCOztBQUVBLGNBQUksQ0FBQyxLQUFLbkIsTUFBVixFQUNFLE9BQU8sQ0FBQ3FCLFFBQVI7QUFDSDtBQUNGOztBQUVELFdBQUt0QixZQUFMLEdBQW9CaEMsS0FBcEI7QUFDQSxXQUFLa0MsY0FBTCxHQUFzQmlCLFlBQXRCOztBQUVBLGFBQU9BLGVBQWUsS0FBS25DLGFBQUwsQ0FBbUJoQixLQUFuQixDQUF0QjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs0QkFRUTZDLEksRUFBTTtBQUNaLFVBQUluQyxlQUFlLEtBQUtBLFlBQXhCO0FBQ0EsVUFBSTZDLGNBQWMsQ0FBQ1YsUUFBUW5DLGFBQWFxQyxXQUF0QixJQUFxQyxLQUFLdkIsS0FBNUQ7QUFDQSxVQUFJZ0MsZ0JBQWdCLEtBQUs1QyxTQUF6QjtBQUNBLFVBQUlvQixlQUFlLEtBQUtBLFlBQXhCOztBQUVBLFVBQUksS0FBS3JCLE1BQVQsRUFBaUI7QUFDZixZQUFJOEMsa0JBQWtCLEdBQXRCO0FBQ0EsWUFBSUMsa0JBQWtCLEdBQXRCO0FBQ0EsWUFBSUMsZ0JBQWdCLEdBQXBCO0FBQ0EsWUFBSUMsaUJBQWlCLEdBQXJCO0FBQ0EsWUFBSVIsaUJBQWlCLEtBQUtBLGNBQTFCOztBQUVBLFlBQUksS0FBS25CLE1BQVQsRUFDRUQsZUFBZUEsZUFBZSxLQUFLaEIsYUFBTCxDQUFtQmQsTUFBakQsQ0FERixLQUdFOEIsZUFBZTNCLEtBQUt5QyxHQUFMLENBQVMsQ0FBVCxFQUFZekMsS0FBS3dELEdBQUwsQ0FBUzdCLFlBQVQsRUFBdUIsS0FBS2hCLGFBQUwsQ0FBbUJkLE1BQW5CLEdBQTRCLENBQW5ELENBQVosQ0FBZjs7QUFFRixZQUFJLEtBQUtjLGFBQVQsRUFDRXlDLGtCQUFrQixLQUFLekMsYUFBTCxDQUFtQmdCLFlBQW5CLEtBQW9DLENBQXREOztBQUVGLFlBQUksS0FBS2QsYUFBVCxFQUNFd0Msa0JBQWtCLEtBQUt4QyxhQUFMLENBQW1CYyxZQUFuQixLQUFvQyxDQUF0RDs7QUFFRixZQUFJLEtBQUtYLFdBQVQsRUFDRXNDLGdCQUFnQixLQUFLdEMsV0FBTCxDQUFpQlcsWUFBakIsS0FBa0MsQ0FBbEQ7O0FBRUY7QUFDQSxZQUFJLEtBQUtILFVBQUwsS0FBb0IsQ0FBcEIsSUFBeUIsS0FBS0MsYUFBTCxHQUFxQixDQUFsRCxFQUFxRDtBQUNuRCxjQUFJZ0MsbUJBQW1CLENBQUN6RCxLQUFLMEQsTUFBTCxLQUFnQixHQUFqQixJQUF3QixHQUF4QixHQUE4QixLQUFLakMsYUFBMUQ7QUFDQThCLDJCQUFpQnZELEtBQUsyRCxHQUFMLENBQVMsR0FBVCxFQUFjLENBQUMsS0FBS25DLFVBQUwsR0FBa0JpQyxnQkFBbkIsSUFBdUMsTUFBckQsQ0FBakI7QUFDRDs7QUFFRDtBQUNBLFlBQUlKLG9CQUFvQixDQUFwQixJQUF5QixLQUFLN0MsU0FBTCxHQUFpQixDQUE5QyxFQUFpRDtBQUMvQyxjQUFJb0QsbUJBQW1CakMsZUFBZSxDQUF0QztBQUNBLGNBQUlrQyxZQUFKLEVBQWtCQyxVQUFsQjs7QUFFQSxjQUFJRixxQkFBcUIsS0FBS2pELGFBQUwsQ0FBbUJkLE1BQTVDLEVBQW9EO0FBQ2xELGdCQUFJLEtBQUsrQixNQUFULEVBQWlCO0FBQ2ZpQyw2QkFBZSxLQUFLbEQsYUFBTCxDQUFtQixDQUFuQixJQUF3Qm9DLGNBQXZDO0FBQ0FlLDJCQUFhLEtBQUs5QyxXQUFMLENBQWlCLENBQWpCLENBQWI7QUFDRCxhQUhELE1BR087QUFDTDZDLDZCQUFlZCxjQUFmO0FBQ0FlLDJCQUFhLENBQWI7QUFDRDtBQUNGLFdBUkQsTUFRTztBQUNMRCwyQkFBZSxLQUFLbEQsYUFBTCxDQUFtQmlELGdCQUFuQixDQUFmO0FBQ0FFLHlCQUFhLEtBQUs5QyxXQUFMLENBQWlCNEMsZ0JBQWpCLENBQWI7QUFDRDs7QUFFRCxjQUFJRyx1QkFBdUJGLGVBQWVULGVBQTFDOztBQUVBO0FBQ0E7QUFDQSxjQUFJRSxnQkFBZ0IsQ0FBcEIsRUFDRVMsd0JBQXdCVCxhQUF4Qjs7QUFFRixjQUFJUSxhQUFhLENBQWpCLEVBQ0VDLHdCQUF3QkQsVUFBeEI7O0FBRUYsY0FBSUMsdUJBQXVCLENBQTNCLEVBQ0VBLHVCQUF1QixDQUF2Qjs7QUFFRjtBQUNBLGNBQUlWLG9CQUFvQixDQUF4QixFQUNFQSxrQkFBa0JVLG9CQUFsQjs7QUFFRjtBQUNBWiwyQkFBaUIsS0FBSzNDLFNBQUwsR0FBaUJ1RCxvQkFBbEM7QUFDRDs7QUFFRDtBQUNBViwyQkFBbUIsS0FBS3RDLFdBQXhCO0FBQ0FzQywyQkFBbUIsS0FBS3ZDLFdBQXhCOztBQUVBO0FBQ0F3Qyx5QkFBaUIsS0FBS3BDLFNBQXRCO0FBQ0FvQyx5QkFBaUIsS0FBS3JDLFNBQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUlxQyxnQkFBZ0IsQ0FBcEIsRUFBdUI7QUFDckJELDZCQUFtQkMsYUFBbkI7QUFDQUYsNkJBQW1CRSxhQUFuQjtBQUNBSix5QkFBZ0JJLGdCQUFnQkMsY0FBaEM7QUFDRCxTQUpELE1BSU87QUFDTEwseUJBQWdCSSxnQkFBZ0JDLGNBQWhDO0FBQ0Q7O0FBRUQ7QUFDQSxZQUFJLEtBQUszQyxXQUFMLEdBQW1CLENBQXZCLEVBQ0V3QyxtQkFBbUIsT0FBT3BELEtBQUswRCxNQUFMLEtBQWdCLEdBQXZCLElBQThCLEtBQUs5QyxXQUF0RDs7QUFFRjtBQUNBLFlBQUl3QyxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDdkI7QUFDQUMsNkJBQW1CRCxlQUFuQjtBQUNBQSw0QkFBa0IsQ0FBbEI7QUFDRDs7QUFFRCxZQUFJQSxrQkFBa0JDLGVBQWxCLEdBQW9DLEtBQUsvQyxNQUFMLENBQVkwRCxRQUFwRCxFQUNFWCxrQkFBa0IsS0FBSy9DLE1BQUwsQ0FBWTBELFFBQVosR0FBdUJaLGVBQXpDOztBQUVGQywyQkFBbUJFLGNBQW5COztBQUVBLFlBQUksS0FBS3pCLFVBQVQsRUFDRSxLQUFLbUMsS0FBTCxDQUFXZixXQUFYOztBQUVGO0FBQ0EsWUFBSSxLQUFLeEIsSUFBTCxHQUFZLENBQVosSUFBaUIyQixrQkFBa0IsQ0FBdkMsRUFBMEM7QUFDeEM7QUFDQSxjQUFJYSxXQUFXN0QsYUFBYWtDLFVBQWIsRUFBZjtBQUNBLGNBQUk0QixTQUFTLEtBQUsvQyxTQUFMLEdBQWlCLEtBQUtDLFNBQUwsR0FBaUJnQyxlQUEvQztBQUNBLGNBQUllLFVBQVUsS0FBSzlDLFVBQUwsR0FBa0IsS0FBS0MsVUFBTCxHQUFrQjhCLGVBQWxEOztBQUVBLGNBQUljLFNBQVNDLE9BQVQsR0FBbUJmLGVBQXZCLEVBQXdDO0FBQ3RDLGdCQUFJZ0IsU0FBU2hCLG1CQUFtQmMsU0FBU0MsT0FBNUIsQ0FBYjtBQUNBRCxzQkFBVUUsTUFBVjtBQUNBRCx1QkFBV0MsTUFBWDtBQUNEOztBQUVELGNBQUlDLGdCQUFnQnBCLGNBQWNpQixNQUFsQztBQUNBLGNBQUlJLGlCQUFpQnJCLGNBQWNHLGVBQW5DO0FBQ0EsY0FBSW1CLG1CQUFtQkQsaUJBQWlCSCxPQUF4Qzs7QUFFQUYsbUJBQVN4QyxJQUFULENBQWNoQyxLQUFkLEdBQXNCLENBQXRCO0FBQ0F3RSxtQkFBU3hDLElBQVQsQ0FBYytDLGNBQWQsQ0FBNkIsR0FBN0IsRUFBa0N2QixXQUFsQztBQUNBZ0IsbUJBQVN4QyxJQUFULENBQWNnRCx1QkFBZCxDQUFzQyxLQUFLaEQsSUFBM0MsRUFBaUQ0QyxhQUFqRDs7QUFFQSxjQUFJRSxtQkFBbUJGLGFBQXZCLEVBQ0VKLFNBQVN4QyxJQUFULENBQWMrQyxjQUFkLENBQTZCLEtBQUsvQyxJQUFsQyxFQUF3QzhDLGdCQUF4Qzs7QUFFRk4sbUJBQVN4QyxJQUFULENBQWNnRCx1QkFBZCxDQUFzQyxHQUF0QyxFQUEyQ0gsY0FBM0M7QUFDQUwsbUJBQVNTLE9BQVQsQ0FBaUIsS0FBS3JDLFVBQXRCOztBQUVBLGVBQUtOLFlBQUwsR0FBb0JrQyxRQUFwQjs7QUFFQTtBQUNBLGNBQUlVLFNBQVN2RSxhQUFhd0Usa0JBQWIsRUFBYjs7QUFFQUQsaUJBQU90RSxNQUFQLEdBQWdCLEtBQUtBLE1BQXJCO0FBQ0FzRSxpQkFBT0UsWUFBUCxDQUFvQnBGLEtBQXBCLEdBQTRCNkQsY0FBNUI7QUFDQXFCLGlCQUFPRCxPQUFQLENBQWVULFFBQWY7O0FBRUFVLGlCQUFPRyxLQUFQLENBQWE3QixXQUFiLEVBQTBCRSxlQUExQjtBQUNBd0IsaUJBQU9JLElBQVAsQ0FBWTlCLGNBQWNHLGVBQTFCOztBQUVBLGVBQUt0QixZQUFMLEdBQW9CNkMsTUFBcEI7QUFDQSxlQUFLM0Msa0JBQUwsR0FBMEJ1QyxnQkFBMUI7QUFDQSxlQUFLdEMsYUFBTCxHQUFxQixLQUFLUixJQUExQjtBQUNBLGVBQUtTLGdCQUFMLEdBQXdCb0MsY0FBeEI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsVUFBSSxLQUFLOUQsU0FBTCxHQUFpQixHQUFyQixFQUNFMEMsaUJBQWlCLE9BQU9uRCxLQUFLMEQsTUFBTCxLQUFnQixHQUF2QixJQUE4QixLQUFLakQsU0FBbkMsR0FBK0MwQyxhQUFoRTs7QUFFRixhQUFPbkQsS0FBS3lDLEdBQUwsQ0FBUyxLQUFLL0IsU0FBZCxFQUF5QnlDLGFBQXpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7MEJBS01YLEksRUFBTTtBQUNWLFVBQU1uQyxlQUFlLEtBQUtBLFlBQTFCO0FBQ0EsVUFBTTRFLFVBQVUsS0FBSzlDLGdCQUFyQjtBQUNBLFVBQU1DLFlBQVlJLFFBQVFuQyxhQUFhcUMsV0FBdkM7O0FBRUEsVUFBSU4sWUFBWTZDLE9BQWhCLEVBQXlCO0FBQ3ZCLFlBQU1WLGlCQUFpQnZFLEtBQUt3RCxHQUFMLENBQVNwQixZQUFZLEtBQUtBLFNBQTFCLEVBQXFDNkMsT0FBckMsQ0FBdkI7QUFDQSxZQUFNZixXQUFXLEtBQUtsQyxZQUF0QjtBQUNBLFlBQUlrRCxtQkFBbUIsS0FBS2hELGFBQTVCOztBQUVBLFlBQUlFLFlBQVksS0FBS0gsa0JBQXJCLEVBQXlDO0FBQ3ZDLGNBQU1rRCxlQUFlLEtBQUtsRCxrQkFBMUI7QUFDQWlELDhCQUFvQixDQUFDOUMsWUFBWStDLFlBQWIsS0FBOEJGLFVBQVVFLFlBQXhDLENBQXBCO0FBQ0Q7O0FBRURqQixpQkFBU3hDLElBQVQsQ0FBYzBELHFCQUFkLENBQW9DaEQsU0FBcEM7QUFDQThCLGlCQUFTeEMsSUFBVCxDQUFjK0MsY0FBZCxDQUE2QlMsZ0JBQTdCLEVBQStDOUMsU0FBL0M7QUFDQThCLGlCQUFTeEMsSUFBVCxDQUFjZ0QsdUJBQWQsQ0FBc0MsQ0FBdEMsRUFBeUNILGNBQXpDOztBQUVBLGFBQUt4QyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsYUFBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLGFBQUtDLGtCQUFMLEdBQTBCLENBQTFCO0FBQ0EsYUFBS0MsYUFBTCxHQUFxQixDQUFyQjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLENBQXhCO0FBQ0Q7QUFDRjs7O3dCQTFTb0I7QUFDbkIsVUFBSSxLQUFLN0IsTUFBVCxFQUFpQjtBQUNmLFlBQUl5QyxpQkFBaUIsS0FBS3pDLE1BQUwsQ0FBWTBELFFBQWpDOztBQUVBLFlBQUksS0FBSzNCLG1CQUFULEVBQ0VVLGtCQUFrQixLQUFLVixtQkFBdkI7O0FBRUYsZUFBT1UsY0FBUDtBQUNEOztBQUVELGFBQU8sQ0FBUDtBQUNEOzs7RUF6U3lCc0MseUI7O2tCQTJrQmJsRixhIiwiZmlsZSI6IlNlZ21lbnRFbmdpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvQXVkaW9UaW1lRW5naW5lJztcblxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcbiAgaWYgKG9wdCAhPT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBvcHQ7XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XG5cbiAgaWYgKHNpemUgPiAwKSB7XG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XG4gICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XG5cbiAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcbiAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xuXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdID4gdmFsdWUpXG4gICAgICAgIGluZGV4LS07XG5cbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCArIDFdIDw9IHZhbHVlKVxuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yTmV4dEluZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xuICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcblxuICBpZiAoc2l6ZSA+IDApIHtcbiAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcblxuICAgIGlmICh2YWx1ZSA8PSBmaXJzdFZhbClcbiAgICAgIGluZGV4ID0gMDtcbiAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxuICAgICAgaW5kZXggPSBzaXplO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcblxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA8IHZhbHVlKVxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggLSAxXSA+PSB2YWx1ZSlcbiAgICAgICAgaW5kZXgtLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG5cbi8qKlxuICogVXNlZCB3aXRoIGEgYnVmZmVyIHRvIHNlcnZlIGF1ZGlvIGZpbGVzIHZpYSBncmFudWxhciBzeW50aGVzaXMuXG4gKlxuICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cbiAqIFdoZW4gXCJzY2hlZHVsZWRcIiwgdGhlIGVuZ2luZSAgZ2VuZXJhdGVzIHNlZ21lbnRzIG1vcmUgb3IgbGVzc8KgcGVyaW9kaWNhbGx5XG4gKiAoY29udHJvbGxlZCBieSB0aGUgcGVyaW9kQWJzLCBwZXJpb2RSZWwsIGFuZCBwZXJpb1ZhciBhdHRyaWJ1dGVzKS5cbiAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cbiAqXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgU2VnbWVudEVuZ2luZWAgd2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgLlxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zZWdtZW50LWVuZ2luZS9pbmRleC5odG1sfVxuICpcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xuICogY29uc3Qgc2VnbWVudEVuZ2luZSA9IG5ldyBhdWRpby5TZWdtZW50RW5naW5lKCk7XG4gKlxuICogc2NoZWR1bGVyLmFkZChzZWdtZW50RW5naW5lKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBbb3B0aW9ucy5idWZmZXI9bnVsbF0gLSBBdWRpbyBidWZmZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RBYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MV0gLSBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcGVyaW9kIHZhcmlhdGlvbiByZWxhdGl2ZVxuICogIHRvIHNlZ21lbnQgcGVyaW9kXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgcG9zaXRpb25zIChvbnNldCB0aW1lc1xuICogIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IGR1cmF0aW9ucyBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wXSAtIEFic29sdXRlIHNlZ21lbnQgZHVyYXRpb24gaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MV0gLSBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnRcbiAqICBkdXJhdGlvbiBvciBpbnRlci1zZWdtZW50IGRpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRBcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IG9mZnNldHMgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0QWJzPS0wLjAwNV0gLSBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRSZWw9MF0gLSBTZWdtZW50IG9mZnNldCByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVsYXk9MC4wMDVdIC0gVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHlcbiAqICB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tBYnM9MC4wMDVdIC0gQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrUmVsPTBdIC0gQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MC4wMDVdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VSZWw9MF0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmc9MF0gLSBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBMaW5lYXIgZ2FpbiBmYWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hYm9ydFRpbWU9MC4wMDVdIC0gZmFkZS1vdXQgdGltZSB3aGVuIGFib3J0ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mXG4gKiAgdGhpcy5wb3NpdGlvbkFycmF5L2R1cmF0aW9uQXJyYXkvb2Zmc2V0QXJyYXkpXG4gKiBAcGFyYW0ge0Jvb2x9IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIHNlZ21lbnQgaW5kaWNlcyBhcmVcbiAqICBjb25zaWRlcmVkIGFzIGN5Y2xpY1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb249MF0gLSBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGJ1ZmZlclxuICogIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXG4gKi9cbmNsYXNzIFNlZ21lbnRFbmdpbmUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zLmF1ZGlvQ29udGV4dCk7XG5cbiAgICAvKipcbiAgICAgKiBBdWRpbyBidWZmZXJcbiAgICAgKiBAbmFtZSBidWZmZXJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcbiAgICAgKiBAbmFtZSBwZXJpb2RBYnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucGVyaW9kQWJzID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RBYnMsIDApO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXItc2VnbWVudCBkaXN0YW5jZVxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wZXJpb2RSZWwgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFJlbCwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIHNlZ21lbnQgcGVyaW9kXG4gICAgICogQG5hbWUgcGVyaW9kVmFyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZFZhciA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kVmFyLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcbiAgICAgKiBAbmFtZSBwZXJpb2RNaW5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDAxXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnBlcmlvZE1pbiA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kTWluLCAwLjAwMSk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IHBvc2l0aW9ucyAob25zZXQgdGltZXMgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcbiAgICAgKiBAbmFtZSBwb3NpdGlvbkFycmF5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvbkFycmF5LCBbMC4wXSk7XG5cbiAgICAvKipcbiAgICAgKiBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXG4gICAgICogQG5hbWUgcG9zaXRpb25WYXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uVmFyLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xuICAgICAqIEBuYW1lIGR1cmF0aW9uQXJyYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFswLjBdXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uQXJyYXksIFswLjBdKTtcblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgZHVyYXRpb24gaW4gc2VjXG4gICAgICogQG5hbWUgZHVyYXRpb25BYnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25BYnMgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uQWJzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgZHVyYXRpb24gcmVsYXRpdmUgdG8gZ2l2ZW4gc2VnbWVudCBkdXJhdGlvbiBvciBpbnRlci1zZWdtZW50IGRpc3RhbmNlXG4gICAgICogQG5hbWUgZHVyYXRpb25SZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAxKTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcbiAgICAgKlxuICAgICAqIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXG4gICAgICogb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb25cbiAgICAgKiBhbmQgdGhlIGR1cmF0aW9uIGhhcyB0byBiZSBjb3JyZWN0ZWQgYnkgdGhlIG9mZnNldFxuICAgICAqXG4gICAgICogQG5hbWUgb2Zmc2V0QXJyYXlcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHQgWzAuMF1cbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0QXJyYXkgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFycmF5LCBbMC4wXSk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcbiAgICAgKiBAbmFtZSBvZmZzZXRBYnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0wLjAwNVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRBYnMgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFicywgLTAuMDA1KTtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAgICAgKiBAbmFtZSBvZmZzZXRSZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0UmVsID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRSZWwsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHkgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXG4gICAgICogQG5hbWUgZGVsYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMDA1XG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmRlbGF5ID0gb3B0T3JEZWYob3B0aW9ucy5kZWxheSwgMC4wMDUpO1xuXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXG4gICAgICogQG5hbWUgYXR0YWNrQWJzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMC4wMDUpO1xuXG4gICAgLyoqXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxuICAgICAqIEBuYW1lIGF0dGFja1JlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5hdHRhY2tSZWwgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja1JlbCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wMDVcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucmVsZWFzZUFicyA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZUFicywgMC4wMDUpO1xuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlbGVhc2VSZWwgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VSZWwsIDApO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc2FtcGxpbmcgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmcsIDApO1xuXG4gICAgLyoqXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nVmFyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlc2FtcGxpbmdWYXIgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmdWYXIsIDApO1xuXG4gICAgLyoqXG4gICAgICogTGluZWFyIGdhaW4gZmFjdG9yXG4gICAgICogQG5hbWUgZ2FpblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBzZWdtZW50IHRvIHN5bnRoZXNpemUgKGkuZS4gb2YgdGhpcy5wb3NpdGlvbkFycmF5L2R1cmF0aW9uQXJyYXkvb2Zmc2V0QXJyYXkpXG4gICAgICogQG5hbWUgc2VnbWVudEluZGV4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IG9wdE9yRGVmKG9wdGlvbnMuc2VnbWVudEluZGV4LCAwKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xuICAgICAqIEBuYW1lIGN5Y2xpY1xuICAgICAqIEB0eXBlIHtCb29sfVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmN5Y2xpYyA9IG9wdE9yRGVmKG9wdGlvbnMuY3ljbGljLCBmYWxzZSk7XG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXN0IHNlZ21lbnQgaXMgYWJvcnRlZCB3aGVuIHRyaWdnZXJpbmcgdGhlIG5leHRcbiAgICAgKiBAbmFtZSBtb25vcGhvbmljXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5tb25vcGhvbmljID0gb3B0T3JEZWYob3B0aW9ucy5tb25vcGhvbmljLCBmYWxzZSk7XG4gICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xuICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcbiAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcbiAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogRmFkZS1vdXQgdGltZSAod2hlbiBhYm9ydGVkKVxuICAgICAqIEBuYW1lIGFib3J0VGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4wMDVcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMuYWJvcnRUaW1lID0gb3B0T3JEZWYob3B0aW9ucy5hYm9ydFRpbWUsIDAuMDA1KTtcblxuICAgIC8qKlxuICAgICAqIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXG4gICAgICogQG5hbWUgd3JhcEFyb3VuZEV4dGVuc2lvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uID0gb3B0T3JEZWYob3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uLCAwKTtcblxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYnVmZmVyIGR1cmF0aW9uIChleGNsdWRpbmcgd3JhcEFyb3VuZEV4dGVuc2lvbilcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIGdldCBidWZmZXJEdXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xuXG4gICAgICBpZiAodGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uKVxuICAgICAgICBidWZmZXJEdXJhdGlvbiAtPSB0aGlzLndyYXBBcm91bmRFeHRlbnNpb247XG5cbiAgICAgIHJldHVybiBidWZmZXJEdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcbiAgICB0aW1lID0gTWF0aC5tYXgodGltZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xuICB9XG5cbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xuICAgIHZhciBjeWNsaWNPZmZzZXQgPSAwO1xuICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XG5cbiAgICBpZiAodGhpcy5jeWNsaWMpIHtcbiAgICAgIHZhciBjeWNsZXMgPSBwb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICBjeWNsaWNPZmZzZXQgPSBNYXRoLmZsb29yKGN5Y2xlcykgKiBidWZmZXJEdXJhdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IGN5Y2xpY09mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoc3BlZWQgPiAwKSB7XG4gICAgICBpbmRleCA9IGdldEN1cnJlbnRPck5leHRJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcblxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gYnVmZmVyRHVyYXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gYnVmZmVyRHVyYXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcbiAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xuXG4gICAgcmV0dXJuIGN5Y2xpY09mZnNldCArIHRoaXMucG9zaXRpb25BcnJheVtpbmRleF07XG4gIH1cblxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XG4gICAgdmFyIGN5Y2xpY09mZnNldCA9IHRoaXMuX19jeWNsaWNPZmZzZXQ7XG5cbiAgICB0aGlzLnRyaWdnZXIodGltZSk7XG5cbiAgICBpZiAoc3BlZWQgPiAwKSB7XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGN5Y2xpY09mZnNldCArPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleC0tO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSBjeWNsaWNPZmZzZXQ7XG5cbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgc2VnbWVudC5cbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lICh3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2NoZWR1bGVkL3RyYW5zcG9ydGVkIG9yIG5vdClcbiAgICogdG8gZ2VuZXJhdGUgYSBzaW5nbGUgc2VnbWVudCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2VnbWVudCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzZWdtZW50IHN5bnRoZXNpcyBhdWRpbyB0aW1lXG4gICAqIEByZXR1cm4ge051bWJlcn0gcGVyaW9kIHRvIG5leHQgc2VnbWVudFxuICAgKi9cbiAgdHJpZ2dlcih0aW1lKSB7XG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xuICAgIHZhciBzZWdtZW50VGltZSA9ICh0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSkgKyB0aGlzLmRlbGF5O1xuICAgIHZhciBzZWdtZW50UGVyaW9kID0gdGhpcy5wZXJpb2RBYnM7XG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XG4gICAgICB2YXIgc2VnbWVudFBvc2l0aW9uID0gMC4wO1xuICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IDAuMDtcbiAgICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gMC4wO1xuICAgICAgdmFyIHJlc2FtcGxpbmdSYXRlID0gMS4wO1xuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcblxuICAgICAgaWYgKHRoaXMuY3ljbGljKVxuICAgICAgICBzZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggJSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoO1xuICAgICAgZWxzZVxuICAgICAgICBzZWdtZW50SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWdtZW50SW5kZXgsIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSk7XG5cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uQXJyYXkpXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XG5cbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uQXJyYXkpXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XG5cbiAgICAgIGlmICh0aGlzLm9mZnNldEFycmF5KVxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXG4gICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcbiAgICAgICAgdmFyIHJhbmRvbVJlc2FtcGxpbmcgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjAgKiB0aGlzLnJlc2FtcGxpbmdWYXI7XG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxjdWxhdGUgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxuICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMCB8fCB0aGlzLnBlcmlvZFJlbCA+IDApIHtcbiAgICAgICAgdmFyIG5leHRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggKyAxO1xuICAgICAgICB2YXIgbmV4dFBvc2l0aW9uLCBuZXh0T2Zmc2V0O1xuXG4gICAgICAgIGlmIChuZXh0U2VnbWVudEluZGV4ID09PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbMF0gKyBidWZmZXJEdXJhdGlvbjtcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5WzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBidWZmZXJEdXJhdGlvbjtcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XG4gICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSBuZXh0UG9zaXRpb24gLSBzZWdtZW50UG9zaXRpb247XG5cbiAgICAgICAgLy8gY29ycmVjdCBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGJ5IG9mZnNldHNcbiAgICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxuICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IDApXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgLT0gc2VnbWVudE9mZnNldDtcblxuICAgICAgICBpZiAobmV4dE9mZnNldCA+IDApXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgKz0gbmV4dE9mZnNldDtcblxuICAgICAgICBpZiAoaW50ZXJTZWdtZW50RGlzdGFuY2UgPCAwKVxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlID0gMDtcblxuICAgICAgICAvLyB1c2UgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBpbnN0ZWFkIG9mIHNlZ21lbnQgZHVyYXRpb25cbiAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMClcbiAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSBpbnRlclNlZ21lbnREaXN0YW5jZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyIG1hcmtlciBkaXN0YW5jZVxuICAgICAgICBzZWdtZW50UGVyaW9kICs9IHRoaXMucGVyaW9kUmVsICogaW50ZXJTZWdtZW50RGlzdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvblxuICAgICAgc2VnbWVudER1cmF0aW9uICo9IHRoaXMuZHVyYXRpb25SZWw7XG4gICAgICBzZWdtZW50RHVyYXRpb24gKz0gdGhpcy5kdXJhdGlvbkFicztcblxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IG9mZnNldFxuICAgICAgc2VnbWVudE9mZnNldCAqPSB0aGlzLm9mZnNldFJlbDtcbiAgICAgIHNlZ21lbnRPZmZzZXQgKz0gdGhpcy5vZmZzZXRBYnM7XG5cbiAgICAgIC8vIGFwcGx5IHNlZ21lbnQgb2Zmc2V0XG4gICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXG4gICAgICAvLyAgIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XG4gICAgICBpZiAoc2VnbWVudE9mZnNldCA8IDApIHtcbiAgICAgICAgc2VnbWVudER1cmF0aW9uIC09IHNlZ21lbnRPZmZzZXQ7XG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSBzZWdtZW50T2Zmc2V0O1xuICAgICAgICBzZWdtZW50VGltZSArPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnRUaW1lIC09IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyByYW5kb21pemUgc2VnbWVudCBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMucG9zaXRpb25WYXIgPiAwKVxuICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wb3NpdGlvblZhcjtcblxuICAgICAgLy8gc2hvcnRlbiBkdXJhdGlvbiBvZiBzZWdtZW50cyBvdmVyIHRoZSBlZGdlcyBvZiB0aGUgYnVmZmVyXG4gICAgICBpZiAoc2VnbWVudFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAvL3NlZ21lbnRUaW1lIC09IGdyYWluUG9zaXRpb247IGhtLCBub3Qgc3VyZSBpZiB3ZSB3YW50IHRvIGRvIHRoaXNcbiAgICAgICAgc2VnbWVudER1cmF0aW9uICs9IHNlZ21lbnRQb3NpdGlvbjtcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiArIHNlZ21lbnREdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKVxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcblxuICAgICAgc2VnbWVudER1cmF0aW9uIC89IHJlc2FtcGxpbmdSYXRlO1xuXG4gICAgICBpZiAodGhpcy5tb25vcGhvbmljKVxuICAgICAgICB0aGlzLmFib3J0KHNlZ21lbnRUaW1lKTtcblxuICAgICAgLy8gbWFrZSBzZWdtZW50XG4gICAgICBpZiAodGhpcy5nYWluID4gMCAmJiBzZWdtZW50RHVyYXRpb24gPiAwKSB7XG4gICAgICAgIC8vIG1ha2Ugc2VnbWVudCBlbnZlbG9wZVxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB2YXIgYXR0YWNrID0gdGhpcy5hdHRhY2tBYnMgKyB0aGlzLmF0dGFja1JlbCAqIHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBzZWdtZW50RHVyYXRpb247XG5cbiAgICAgICAgaWYgKGF0dGFjayArIHJlbGVhc2UgPiBzZWdtZW50RHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gc2VnbWVudER1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xuICAgICAgICAgIGF0dGFjayAqPSBmYWN0b3I7XG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IHNlZ21lbnRUaW1lICsgYXR0YWNrO1xuICAgICAgICB2YXIgc2VnbWVudEVuZFRpbWUgPSBzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbjtcbiAgICAgICAgdmFyIHJlbGVhc2VTdGFydFRpbWUgPSBzZWdtZW50RW5kVGltZSAtIHJlbGVhc2U7XG5cbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XG4gICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50VGltZSk7XG4gICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcblxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmdhaW4sIHJlbGVhc2VTdGFydFRpbWUpO1xuXG4gICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50RW5kVGltZSk7XG4gICAgICAgIGVudmVsb3BlLmNvbm5lY3QodGhpcy5vdXRwdXROb2RlKTtcblxuICAgICAgICB0aGlzLl9fY3VycmVudEVudiA9IGVudmVsb3BlO1xuXG4gICAgICAgIC8vIG1ha2Ugc291cmNlXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGVudmVsb3BlKTtcblxuICAgICAgICBzb3VyY2Uuc3RhcnQoc2VnbWVudFRpbWUsIHNlZ21lbnRQb3NpdGlvbik7XG4gICAgICAgIHNvdXJjZS5zdG9wKHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uKTtcblxuICAgICAgICB0aGlzLl9fY3VycmVudFNyYyA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSByZWxlYXNlU3RhcnRUaW1lO1xuICAgICAgICB0aGlzLl9fY3VycmVudEdhaW4gPSB0aGlzLmdhaW47XG4gICAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IHNlZ21lbnRFbmRUaW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlZ21lbnQgcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cbiAgICBpZiAodGhpcy5wZXJpb2RWYXIgPiAwLjApXG4gICAgICBzZWdtZW50UGVyaW9kICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucGVyaW9kVmFyICogc2VnbWVudFBlcmlvZDtcblxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgc2VnbWVudFBlcmlvZCk7XG4gIH1cblxuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgc2VnbWVudCBhdCBnaXZlbiB0aW1lLCBmYWRlIG91dCBkdXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGFib3J0IHRpbWVcbiAgICovXG4gIGFib3J0KHRpbWUpIHtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcbiAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5fX2N1cnJlbnRFbmRUaW1lO1xuICAgIGNvbnN0IGFib3J0VGltZSA9IHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xuXG4gICAgaWYgKGFib3J0VGltZSA8IGVuZFRpbWUpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnRFbmRUaW1lID0gTWF0aC5taW4oYWJvcnRUaW1lICsgdGhpcy5hYm9ydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgY29uc3QgZW52ZWxvcGUgPSB0aGlzLl9fY3VycmVudEVudjtcbiAgICAgIGxldCBjdXJyZW50R2FpblZhbHVlID0gdGhpcy5fX2N1cnJlbnRHYWluO1xuXG4gICAgICBpZiAoYWJvcnRUaW1lID4gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZVN0YXJ0ID0gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWU7XG4gICAgICAgIGN1cnJlbnRHYWluVmFsdWUgKj0gKGFib3J0VGltZSAtIHJlbGVhc2VTdGFydCkgLyAoZW5kVGltZSAtIHJlbGVhc2VTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGVudmVsb3BlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGFib3J0VGltZSk7XG4gICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKGN1cnJlbnRHYWluVmFsdWUsIGFib3J0VGltZSk7XG4gICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHNlZ21lbnRFbmRUaW1lKTtcblxuICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xuICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xuICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xuICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcbiAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlZ21lbnRFbmdpbmU7XG4iXX0=